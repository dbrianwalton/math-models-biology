<?xml version="1.0" encoding="UTF-8"?>

<!-- This file is part of the book                -->
<!--                                              -->
<!--      Mathematical Models in Biology         -->
<!--                                              -->
<!-- Copyright (C) 2017  D. Brian Walton          -->
<!-- See the file COPYING for copying conditions. -->
   
<section xml:id="projection-analysis">
<title>Analysis of Population Projections</title>

<introduction>
    <p>
        When we introduced projection functions that define a sequence recursively, <m>x_{n+1} = f(x_n)</m>, we discussed the relationship between fixed points of the projection function and equilibria of the sequence being studied.
        In this section, we will consider the analysis of projection functions in order to study the stability of equilibria.
        A stable equilibrium is likely to be observed in a physical setting.
        An unstable equilibrium is unlikely to be observed as small deviations from equilibrium push the system away from the steady state.
    </p>
    <p>
        We will first consider a prototype example, where the projection function is a linear function.
        That system generalizes the geometric sequence related to constant per capita growth.
        For more complex models, we will then discuss using a linear approximation near the fixed point (i.e., a tangent line) to analyze equilibrium stability.
        We conclude with a graphical representation of sequences generated by projection functions that is commonly referred to as a cobweb diagram.
    </p>
</introduction>
    
<subsection xml:id='linear-projection-analysis'>
    <title>Linear Projection Functions</title>
    
    <p>
        We begin by considering the consequence of using a linear function as a projection function.
        Mathematics texts usually introduce linear functions using the slope<ndash/>intercept form, <m>f(x)=mx+b</m> where <m>m</m> and <m>b</m> are model parameters (slope and intercept).
        However, we will more frequently use the point<ndash/>slope form, <m>f(x)=m(x-a)+b</m>, which has slope <m>m</m> and passes through a point <m>(a,b)</m>, or more precisely, <m>f(a)=b</m>.
        As an additional warning, note in advance that we will often use symbols other than <m>m</m> to represent slope.
    </p>

    <example>
        <p>
            Consider a population model that uses a constant per capita growth rate <m>r</m> for which we introduce an emigration term that is constant, say <m>E_{n} = m</m> (for migration).
            Then our population model would be 
            <me>\hbox{New Population} = \hbox{Old Population} + \hbox{Natural Growth} - \hbox{Emigration}</me>.
            Using sequences, this would be written
            <me>P_{n+1} = P_{n} + r \cdot P_n - m = (1+r) P_n - m</me>.
            The projection function for this model is linear with a slope <m>\alpha = 1+r</m> given by
            <me>f(x) = \alpha x - m = (1+r)x - m</me>.
        </p>
    </example>
    <example>
        <statement>
            <p>
                Consider a population that is decreasing by 5<percent/> per year.
                Suppose an intervention is established that supplements the population by 100 new individuals per year.
            </p>
            <p>
                Express a recursive sequence model for this population and identify the projection function.
            </p>
        </statement>
        <solution>
            <p>
                The recursive model for the population is motivated by the descriptive equation
                <me>\hbox{New Population} = \hbox{Old Population} - \hbox{Natural Losses} + \hbox{Supplements}</me>.
                If <m>P_n</m> is the population after <m>n</m> years, then our recursive model is 
                <md>
                    <mrow>P_{n+1} \amp = P_n - 0.05 P_n + 100</mrow>
                    <mrow> \amp = 0.95 P_n + 100</mrow>.
                </md>
                We identify the projection function <m>P_{n+1} = f(P_n)</m> as
                <me>f(x) = 0.95 x + 100</me>,
                which is linear with slope <m>\alpha=0.95</m>.
            </p>
        </solution>
    </example>
    <example>
        <statement>
            <p>
                A loan balance grows by <m>1/12</m> of the annual percentage rate each month.
                But a monthly payment reduces the loan balance.
                Write down a recursive model for the loan balance <m>B_n</m> where <m>n</m> is the number of months since the loan began, <m>r</m> is the annual percentage rate and <m>p</m> is the amount of the monthly payment.
            </p>
        </statement>
        <solution>
            <p>
                The recursive model for the loan balance is motivated by the descriptive equation
                <me>\hbox{New Balance} = \hbox{Old Balance} + \hbox{Added Interest} - \hbox{Monthly Payment}</me>.
                Our recursive model is
                <md>
                    <mrow>B_{n+1} \amp = B_n + \frac{r}{12} B_n - m </mrow>
                    <mrow> \amp = (1+\frac{r}{12}) B_n - m</mrow>.
                </md>
                The projection function is therefore
                <me>f(x) = (1+\frac{r}{12}) x - m</me>,
                which is linear with slope <m>\alpha = 1+\frac{r}{12}</m>.
            </p>
        </solution>
    </example>
    <p>
        The first step in analysis is to identify the fixed points which we use to rewrite our function.
        A linear projection function <m>f(x)=\alpha x + \beta</m> for constants <m>\alpha</m> (alpha) and <m>\beta</m> (beta) has exactly one fixed point so long as <m>\alpha \ne 1</m>.
        Recall that a fixed point is a solution <m>x^*</m> to the equation <m>x=f(x)</m>:
        <md>
            <mrow>x^* = \alpha x^* + \beta</mrow>
            <mrow>x^*-\alpha x^* = \beta </mrow>
            <mrow>(1-\alpha) x^* = \beta </mrow>
            <mrow>x^* = \frac{\beta}{1-\alpha} = \frac{-\beta}{\alpha-1}.</mrow>
        </md>
        Because it is a fixed point, we know <m>f(x^*)=x^*</m> and the slope is <m>\alpha</m>. Rewriting <m>f(x)</m> in point<ndash/>slope form, we find the alternative representation
        <me>f(x) = \alpha(x-x^*) + x^*</me>.
    </p>
    <p>
        The new representation allows us to rewrite our recursive equation for the sequence.
        Suppose that <m>x_n</m> refers to a sequence generated by the projection function <m>x_{n+1} = f(x_n)</m>.
        Using the new representation, this becomes
        <me>x_{n+1} = \alpha (x_n-x^*) + x^*</me>.
        This is equivalent to the equation
        <me>x_{n+1} - x^* = \alpha (x_n - x^*)</me>.
        If we define a new sequence <m>z_n</m> as the difference between <m>x_n</m> and the fixed point <m>x^*</m>,
        <me>z_n = x_n - x^*</me>,
        then our equation is showing that the difference is a geometric sequence,
        <me>z_{n+1} = \alpha z_n</me>.
        Geometric sequences have an explicit formula
        <me>z_n = z_0 \cdot \alpha^n</me>,
        which leads to an explicit formula for <m>x_n</m> given by
        <me>x_n = x^* + z_n = x^* + (x_0 - x^*) \cdot \alpha^n</me>.
        For this reason, I call such sequences a <term>shifted geometric sequence</term>,
        where the sequence has been shifted to be centered around the fixed point <m>x^*</m>.
    </p>
    <p>
        Now that we have an explicit formula for our sequence, we can analyze the stability.
        The geometric sequence <m>z_n = z_0 \cdot \alpha^n</m> corresponds to repeated multiplication by the same number <m>\alpha</m>.
        When <m>\alpha \lt 0</m> (negative), the sings of <m>z_n</m> alternate between positive and negative.
        When <m>|\alpha| \gt 1</m>, the sequence <m>z_n</m> grows in magnitude;
        when <m>|\alpha| \lt 1</m>, the magnitude of <m>z_n</m> converges to zero.
    </p>
    
    <theorem xml:id='thm-linear-projection-stability'>
        <title>Stability of Fixed Points for Linear Projection Functions</title>
        <statement>
            <p>
                For a projection function <m>f(x)=\alpha x + \beta</m> with fixed point
                <me>\displaystyle x^* = \frac{\beta}{1-\alpha} = \frac{-\beta}{\alpha-1}</me>,
                the stability of the fixed point as an equilibrium for a sequence defined as <m>x_{n+1} = f(x_n)</m> is determined by the value of the slope <m>\alpha</m>.
                <ul>
                    <li>If <m>|\alpha| \lt 1</m>, then every sequence converges <m>x_n \to x^*</m> and <m>x^*</m> is a <term>locally stable</term> equilibrium.</li>
                    <li>If <m>|\alpha| \gt 1</m>, then every sequence with <m>x_0 \ne x^*</m> diverges away from <m>x^*</m> and <m>x^*</m> is a <term>locally unstable</term> equilibrium.</li>
                    <li>If <m>\alpha = -1</m>, then the sequence <m>x_n</m> alternates between two values and <m>x^*</m> is <term>neutrally stable</term> as the sequence does not diverge.</li>
                    <li>If <m>\alpha = 1</m> and <m>\beta=0</m> (<m>f(x)=x</m>), then every number is a fixed point. If <m>\beta \ne 0</m>, then no fixed point exists.</li>
                </ul>
            </p>
        </statement>
    </theorem>
    
    <example>
        <p>
            Explore the results of the theorem through the interactive activity below.
            The figure below includes slides with which you will be able to choose the slope <m>\alpha</m>, the initial value <m>x_0</m> and the desired fixed point <m>x^*</m>.
            The first few terms of the result sequence defined by <m>x_{n+1}=x^* + a (x_n - x^*)</m> with initial value <m>x_0</m> will then be shown.
            The equilibrium value is shown with a dashed line.
        </p>
        <figure>
            <caption>Graph showing a shifted geometric sequence</caption>
            <interactive platform="jsxgraph" xml:id="jsxgraph-shifted-geometric-sequence" source="code/jsx/jsx-shifted-geometric-sequence.js" aspect="1:1">
                <slate xml:id="jsxboard-shifted-geometric-sequence" surface="jsxboard" aspect="1:1" />
            </interactive>
        </figure>
        <p>
            Did you observe the following features?
            <ul>
                <li>When <m>a \gt 1</m>, the sequence runs away from the equilibrium, staying on the same side as the initial value.</li>
                <li>When <m>0 \lt a \lt 1</m>, the sequence runs toward the equilibrium from the same side as the initial value.</li>
                <li>When <m>-1 \lt a \lt 0</m>, the sequence runs toward the equilibrium but alternating sides.</li>
                <li>When <m>a \lt -1</m>, the sequence runs away the equilibrium but alternating sides.</li>
            </ul>
        </p>
    </example>
</subsection>

<subsection>
    <title>Linearizing Projection Functions</title>
    <p>
        Most functions are not linear, so it might seem that the previous results are limited to just a few special cases.
        However, one of the basic premises of calculus is that many functions can be approximated by linear functions locally.
        That linear function corresponds to the <term>tangent line</term>, which exists so long as the function is <term>differentiable</term>.
    </p>
    <theorem xml:id='thm-function-linearization'>
        <statement>
            <p>
                If a function <m>f</m> is differentiable at <m>x=c</m> (<m>f'(c)</m> exists), then we can define the linear approximation of <m>f</m> around <m>x=c</m>.
                The linearization is the linear function with slope <m>f'(c)</m> and passing through the point <m>(c,f(c))</m> given by
                <me>L_{f,c}(x) = f(c) + f'(c) \cdot (x-c)</me>.
                When <m>x</m> is sufficiently close to <m>c</m>, the functions are nearly indistinguishable.
            </p>
        </statement>
        <proof>
            <p>
                The tangent line equation is a consequence of standard calculus definitions.
                To clarify the idea of sufficiently close without trying to recreate an entire course in analysis, let us start by pointing out that because <m>f'(c)</m> exists, the average rate of change defined by <m>\frac{f(x)-f(c)}{x-c}</m> must converge to <m>f'(c)</m> as <m>x</m> approaches <m>c</m>, as given in the limit
                <me> \lim_{x \to c} \frac{f(x)-f(c)}{x-c} = f'(c)</me>.
                This is equivalent to saying
                <me>\lim_{x \to c} \left(\frac{f(x)-f(c)}{x-c} - f'(c)\right) = 0</me>.
                This can be rewritten as
                <me>\lim_{x \to c} \frac{f(x)-L_{f,c}(x)}{x-c} = 0</me>.
                Because the denominator goes to zero, the numerator must go to zero even faster for the limit to equal zero.
            </p>
        </proof>
    </theorem>
    <p>
        Now, suppose that we are working with a projection function <m>f</m> with a fixed point at <m>x=x^*</m>.
        This means that <m>f(x^*) = x^*</m>.
        The tangent line of the projection function around the fixed point will be
        <me>L_{f,x^*}(x) = f(x^*) + f'(x^*) \cdot (x-x^*) = x^* + f'(x^*) \cdot (x-x^*)</me>.
        By construction, we know that <m>x=x^*</m> is a fixed point of the linearized projection function and the stability of the fixed point as an equilibrium is determined by the slope <m>f'(x^*)</m>.
        The following theorem guarantees that so long as <m>|f'(x^*)| \ne 1</m>, the stability of the fixed point for the projection function is the same as the linearized function. (There is no clear conclusion if <m>|f'(x^*)| = 1</m>.)
    </p>
    <theorem xml:id='thm-projection-fixed-point-stability'>
        <title>Stability of Fixed Points for Projection Functions</title>
        <statement>
            <p>Suppose a projection function <m>f</m> has a fixed point at <m>x=x^*</m> and <m>f'(x^*)</m> exists. So long as <m>|f'(x^*)| \ne 1</m>, the local stability of the fixed point is determined by the value of <m>f'(x^*)</m> as follows. <ul>
                <li>If <m>|f'(x^*)| \lt 1</m>, then <m>x^*</m> is a locally stable fixed point.</li>
                <li>If <m>|f'(x^*)| \gt 1</m>, then <m>x^*</m> is a locally unstable fixed point.</li>
            </ul></p>
        </statement>
    </theorem>
</subsection>

<subsection>
    <title>Computer Assisted Analysis</title>
    
    <p>
        This course has the assumption that you have completed a first semester university calculus course.
        Therefore, it is assumed that you are able to calculate basic derivatives and integrals.
        However, there are many computational tools available that can compute these directly and help us avoid mistakes.
        Here, I introduce you to one such service called SageMath that supports an open-source mathematical programming language called Sage.
        You can get a blank Sage cell in which you can perform computations at the following link: <url href="https://sagecell.sagemath.org/"/>.
        Note that from this site, you are actually able to choose from a variety of different languages.
        When doing algebraic manipulation of formulas as described here, be sure to choose the language <c>Sage</c>.
        This text embeds Sage cells within the document with the language set by default.
        (We have seen previous SageMath cells with the language set to R previously.)
    </p>
    <p>
        Sage is built on top of Python, and any valid Python code can be included with Sage commands.
        In our work with R, we have stored results in <term>variables</term> that represent memory locations to keep track of data.
        Sage allows us to create objects that represent constants, variables, and formulas in a mathematical sense.
        We then can manipulate those mathematical objects.
    </p>
    <p>
        Suppose we wanted to consider a projection function <m>f(x) = x+0.2x(1-0.005x)</m>.
        The tasks we want to accomplish are as follows:
        <ul>
            <li><p>Define our projection formula.</p></li>
            <li><p>Solve for the fixed points of the formula.</p></li>
            <li><p>Calculate the derivative of the projection formula.</p></li>
            <li><p>Evaluate the derivative at each identified fixed point.</p></li>
        </ul>
        After we see the mathematical results, we will apply <xref ref="thm-projection-fixed-point-stability"/> to determine stability.
    </p>
    <p>
        The process of defining a formula in Sage requires first declaring all math symbols that will be variables.
        In our example, the only variable is <m>x</m>.
        Sometimes we might have parameters that we leave in symbolic form and they would also need to be declared.
        The Sage command for declaring a variable is the function <c>var(...)</c>, where the input consists of variable names in quotes and separated by commas.
        This command must be evaluated before we start using the symbols in a formula.
        For our problem, we will use the command <c>var("x")</c>.
    </p>
    <p>
        To actually define our expression, we need to choose a name for the expression for later reference as a programming variable name.
        Where R prefers that we use the assignment operators <c>&lt;-</c> or <c>-&gt;</c>, Python (and therefore Sage) requires the assignment operator is always <c>=</c>, with the variable name on the left side of the statement.
        To declare our example as <c>my_projection</c> we would type the statement <c>my_projection = x + 0.2*x*(1-0.05*x)</c>.
        Notice how we need to explicitly type <c>*</c> for multiplication.
    </p>
    <p>
        Sage is able to solve basic algebraic equations directly using the command <c>solve(...)</c>.
        In the current problem, there is only one equation, but because we often want to solve a <term>system</term> of equations, we will put a <em>list</em> of equations with only one list inside square brackets.
        Because <c>=</c> is used for variable assignment, most computer languages including Python and R use a double equal <c>==</c> for creating equations that are true or false.
        A solution will be a specific value of the variable <m>x</m>, so we also need to specify what we are solving for.
        In the future, we will again be solving for multiple variables, we will again use a <em>list</em> of variables we are solving to find.
        Because we are solving <m>f(x) = x</m>, the basic command will therefore be <c>solve([my_projection == x], [x])</c>, and it returns a <em>list</em> of equations that solve the problem.
    </p>
    <p>
        Just as <c>solve</c> was the command to solve an equation, we will use a command <c>derivative</c> to find the derivative of our formula.
        Because there are potentially many symbols representing variables, we need to specify the symbol for the independent variable as part of the command.
        To differentiate <m>f(x)</m> with respect to <m>x</m>, we tell our expression object <c>my_projection</c> to perform an action <c>derivative</c> with respect to <m>x</m> using the syntax <c>my_projection.derivative(x)</c>.
        If the variable was something other than <m>x</m>, we just change that part of the formula.
    </p>
    <p>
        We will store the results of solving the equation and finding the derivative so that we can use the results later.
        The last thing we need to do is to evaluate the derivative at the point of the solution to the fixed point equation.
        Suppose we named the result of our derivative <c>f_prime</c>.
        We need to tell that object to make a substitution using the <c>subs</c> command.
        We can also ask that the result is simplified as much as possible.
        Since we want to do this for <em>each</em> fixed point solution, we will do this step in a loop.
    </p>
    <p>
        The entire structure of our analysis is accomplished with the following commands.
    </p>
    
    <sage>
        <input>
        <![CDATA[# Declare the variables
        var("x")

        # Define the function
        my_projection = x+0.2*x*(1-0.005*x)
        show(my_projection)

        # Find the derivative
        f_prime = my_projection.derivative(x)
        show(f_prime)
        
        # Solve the fixed point equation. Returns a list.
        fixed_points = solve( [my_projection == x], [x] )
        for fp in fixed_points:
            print("Fixed point", fp)
            slope = f_prime.subs(fp).simplify()
            print("Calculated slope", slope)
        ]]>
        </input>
    </sage>
    <p>
        The previous code will show formulas giving
        <me>f(x) = 0.2x(-0.005x + 1) + x</me>
        and
        <me>f'(x) = -0.002 x + 1.200</me>.
        It identifies fixed points at <m>x=0</m> and <m>x=200</m>.
        Surprisingly, when evaluating <m>f'(200)</m>, it gives a value <m>0.79999999999</m>.
        This is a consequence of computers being unable to represent numbers in decimal form exactly.
        If you changed the code to use <c>2/10</c> instead of <c>0.2</c> and <c>5/1000</c> instead of <c>0.005</c>, you will get exact results.
        That is, we find that <m>f'(0) = \frac{6}{5} = 1.2</m> and <m>f'(200) = \frac{4}{5} = 0.8</m>.
    </p>
    <p>
        It is <em>our</em> task to interpret the results.
        Because the slope of the projection function at the fixed point <m>x=0</m> is <em>greater than</em> 1, the fixed point <m>x=0</m> is a locally unstable fixed point.
        However, because <m>f'(200)</m> has a value 0.8 which is positive and less than 1, the fixed point <m>x=200</m> is locally stable.
        If a population starts small and close to <m>x=0</m>, the subsequent population values will move farther away from 0.
        (This is good for a population as it is increasing in size.)
        On the other hand, a population that is close to 200 will move closer to 200, as that fixed point is stable.
        The population value of 200 acts as a <term>carrying capacity</term>.
    </p>
    <example>
        <statement>
            <p>
                Use computer analysis to find the fixed points for the discrete logistic model <m>P_{n+1} = (1+r_0)P_n - a P_n^2</m>. Find the slopes <m>f'(x^*)</m> for each fixed point and then discuss how the stability depends on the values of the parameters.
            </p>
        </statement>
        <solution>
            <p>
                The projection function is <m>f(x) = (1+r_0) x - a x^2</m>, which is a function of <m>x</m> involving two additional parameters <m>r_0</m> and <m>a</m>.
                To perform our analysis using Sage, we will need to declare all three symbols as mathematical variables.
                Nevertheless, we can still solve the fixed point equation for <m>x</m>, and Sage will provide answers in terms of the paramters.
            </p>
            <sage>
                <input>
                <![CDATA[# Declare the variables
                var("x,r0,a")

                # Define the function
                my_projection = (1+r0)*x - a*x^2
                show(my_projection)

                # Find the derivative
                f_prime = my_projection.derivative(x)
                show(f_prime)
                
                # Solve the fixed point equation. Returns a list.
                fixed_points = solve( [my_projection == x], [x] )
                for fp in fixed_points:
                    print("Fixed point", fp)
                    slope = f_prime.subs(fp).simplify()
                    print("Calculated slope", slope)
                ]]>
                </input>
            </sage>
            <p>
                When you evaluate that work, we will match results we would get using basic calculus.
                If <m>f(x) = (1+r_0)x - ax^2</m>, we know how to find a derivative as
                <me>f'(x) = (1+r_0) - 2 a x</me>.
                Similarly, we can algebraically write down the fixed point equation and solve it by hand:
                <md>
                    <mrow>f(x) \amp = x </mrow>
                    <mrow>(1+r_0)x - a x^2 \amp = x </mrow>
                    <mrow>x+r_0 x - a x^2 \amp = x </mrow>
                    <mrow>r_0 x - a x^2 \amp = 0</mrow>
                    <mrow>x(r_0 - a x) \amp = 0</mrow>
                </md>
                Because this equation says the product of <m>x</m> with <m>r_0 - ax</m> equals zero, the solutions are found by setting each factor individually to zero, giving us <m>x=0</m> and <m>x = \frac{r_0}{a}</m> as our two solutions.
                This matches what Sage tells us.
            </p>
            <p>
                From our Sage work, or by evaluating <m>f'(0)</m>, we find <m>f'(0) = 1+r_0</m>.
                This means that whenever <m>r_0 \gt 0</m>, <m>f'(0) \gt 1</m>.
                By <xref ref="thm-projection-fixed-point-stability"/>, we now know that <m>x^* = 0</m> is an unstable fixed point whenever <m>r_0 \gt 0</m>
                It is actually possible to have <m>-1 \lt r_0 \lt 0</m> if the per capita death rate exceeds the per capita birth rate.
                In that circumstance, we have <m>0 \lt f'(0) \lt 1</m>.
                Consequently, <m>x^*=0</m> is a stable fixed when the death rate exceeds the birth rate for <m>P=0</m>.
            </p>
            <p>
                For the second fixed point <m>x^* = \frac{r_0}{a}</m>, we have <m>f'(x^*) = 1 - r_0</m>.
                We think through the same conditions as above.
                If <m>-1 \lt r_0 \lt 0</m> (negative <m>r_0</m>), we have <m>f'(x^*) \gt 1</m> but we also have a fixed point <m>x^* \lt 0</m> with a negative value.
                In the current setting for populations, <m>P\lt 0</m> does not make sense.
                But mathematically, such a negative fixed point would be unstable.
                If <m>0 \lt r_0 \lt 1</m>, we have <m>f'(x^*)</m> between 0 and 1, which means the fixed point is locally stable and sequences converge without oscillation.
                Once we have <m>r_0 \gt 1</m>, we have <m>f'(x*) \lt 0</m> so that nearby sequences oscillate above and then below the fixed point. 
                For <m>1 \lt r_0 \lt 2</m>, we have <m>|f'(x^*)| \lt 1</m> and the oscillation decays away to the stable fixed point.
                Once we have <m>r_0 \gt 2</m>, this causes <m>|f'(x^*)| \gt 1</m> such that oscillation grows and the fixed point is locally unstable.
            </p>
        </solution>
    </example>
</subsection>
</section>