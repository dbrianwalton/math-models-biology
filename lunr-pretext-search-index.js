var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "front-colophon",
  "level": "1",
  "url": "front-colophon.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "  "
},
{
  "id": "scientific-method",
  "level": "1",
  "url": "scientific-method.html",
  "type": "Section",
  "number": "1.1",
  "title": "The Scientific Method",
  "body": " The Scientific Method  When hearing others talk about the scientific method, I sometimes come away with the impression that science is a well-planned, structured process that always follows the same pattern, like a list that should be memorized: (1) Make an observation, (2) Ask a question, (3) Develop a hypothesis, (4) Use the hypothesis to make a prediction, (5) Test the hypothesis's prediction with an experiment, (6) Analyze the data of the experiment, and (7) Interpret the results in the context of the hypothesis. Rinse and repeat. But science is not always performed in this simple cycle, following this rigid ordering. Rather than describing the mechanics of science, the scientific method summarizes the philosophy of science and how scientists establish scientific knowledge.  At the heart of the scientific method is the idea of a hypothesis. Scientists and mathematicians use the word hypothesis in different ways. For a scientist, a hypothesis is a proposal that describes how some natural phenomenon occurs. It makes possible the prediction of observable outcomes separate from the observed phenomenon itself. For a mathematician, a hypothesis is a logical statement (a sentence which can be definitively determined to be either true or false) that is part of an implication whereby the truth of the hypothesis guarantees the true of the conclusion. In terms of English language, an implication is an if then statement, where the clause following then (the conclusion) is guaranteed to be true whenever the clause following if (the hypothesis) happens to be true.  For a scientist, a hypothesis itself is never directly analyzed. That is, a scientist looks for the consequences of a hypothesis, which are the expected outcomes of an experiment if the hypothesis is assumed to be true. A well-designed experiment tests to see if these outcomes appear as expected. The failure to achieve the expected outcomes is seen as evidence that the hypothesis is false, and the proposed hypothesis is rejected . The successful appearance of the proposed outcomes, however, does not prove the hypothesis was true, for they may have arisen for alternative reasons. For this reason, success is often phrased as failure to reject the hypothesis.  For a mathematician, hypotheses are directly analyzed. Theorems form clear logical relationships between hypotheses and conclusions of implications, whereby the conclusion can be guaranteed to be true under the condition that the hypothesis is true. Proofs form the logical framework by which these relationships are established. The hypotheses themselves are tested in specific circumstances in order to learn whether the conclusion is guaranteed under those particular circumstances without needing to work through the details of the relationship each time.  The difference between a scientist's view and a mathematician's view of the role of a hypothesis provides the distinction between two types of reasoning: inductive reasoning and deductive reasoning.  Inductive reasoning (not to be confused with mathematical induction) is the reasoning exemplified by a scientist. Through observations, a scientist identifies a pattern. A hypothesis is formed that summarizes all past observations and makes predictions about future observations. Through additional observations, additional support can strengthen the evidence for the hypothesis, but the hypothesis itself can never be fully proved to be true. Through a failed prediction, however, the hypothesis can be proved to be false.  Deductive reasoning is the reasoning exemplified by a mathematician. Through logical reasoning, a connection is made between two properties (expressed as logical statements) whereby the presence of one property (the hypothesis) is enough to guarantee the presence of the second property (the conclusion). The truth of this guarantee is absolutely established with logic, built on a core foundation of basic assumptions. The only room for uncertainty is in the validity of the foundational assumptions, which includes the nature of logic and what is meant by truth.  While scientists and mathematicians may philosophically associate themselves more strongly with either inductive reasoning or deductive reasoning, they each spend time with both.  In the formation of a useful hypothesis, a scientist must consider the predictive power of the hypothesis. A strong hypothesis leads to the prediction of results that would not be anticipated without that hypothesis, and so the scientist uses deductive reasoning to formulate predictions based on the hypothesis. In many cases, particularly where mathematical modeling occurs, these predictions use the full power of deduction through the use of mathematical calculation and proof.  Similarly, a mathematician is often interested in establishing new relationships, formulating and then proving new theorems. Such relationships are often found by identifying patterns in calculations or structures. For mathematicians, these patterns (called conjectures ) are supported or refuted by new examples until the mathematician can identify the thread of reasoning that either proves or disproves the relationship.  "
},
{
  "id": "scientific-method-3",
  "level": "2",
  "url": "scientific-method.html#scientific-method-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "hypothesis "
},
{
  "id": "scientific-method-5",
  "level": "2",
  "url": "scientific-method.html#scientific-method-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Theorems Proofs "
},
{
  "id": "scientific-method-11",
  "level": "2",
  "url": "scientific-method.html#scientific-method-11",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "conjectures "
},
{
  "id": "role-of-models",
  "level": "1",
  "url": "role-of-models.html",
  "type": "Section",
  "number": "1.2",
  "title": "The Role of Models",
  "body": " The Role of Models  When I was young, I enjoyed building model kits of airplanes, cars, and boats. These models were made from different materials and were much smaller than the physical objects they represented. Not all parts were present, but the essentials were represented. Sometimes, complicated physical objects such as the engine of a car were represented by a simplified set of model parts. For my models, the goal was a visual representation of a physical object that could illustrate the placement and relationship of parts. Engineers often design scale models that provide both visual and functional representations, as they need to verify that not only will the parts fit together but they will work together as designed.  A biologist often has a very different idea in mind. One common use of the word model in biology has reference to a model organism . For example, a scientist trying to understand medical treatments, ethical and financial considerations impact which organism is used. Mice and rats are often used as model organisms because past research has shown that experimental results often successfully generalize to other mammals, and humans in particular. However, sometimes the differences can be important, so closer models such as pigs or monkeys may be sought for more advanced tests.  The models we will work with for mathematical modeling have some similarities and some differences with the physical models described above. One of the key similarities is that a model is an incomplete representation of reality, but with enough relationships between the model and reality that conclusions drawn from the model may be generalized to the reality it represents. Second, the model replaces the complicated realities with simplified replacements, for example by summarizing complicated interactions with a single equation or relationship that summarizes what is believed to be most relevant. However, in some cases, a mathematical model does not try to capture any particular reality but rather attempts to summarize general features and learn what consequences follow from those general features. For example, instead of recognizing a population as a collection of individuals interacting, a mathematical model may look at some expected average behavior and treat the population as a single quantity.  Mathematical modeling plays a key role in the use of hypotheses in the scientific method. For example, a biologist may believe that the manner in predator and prey populations interact is the key to understanding why the populations have a boom and bust cycle. A mathematical model allows the scientist to codify their understanding of population interactions using equations. This model then can provide predictions that could be used in the interpretation of an actual experiment, such as determining if the boom--bust cycle arises in the numerical model, or if other behavior arises. Analyzing the model might also allow the scientist to determine how the interactions might be manipulated to arrive at other outcomes.    Diagram illustrating the modeling cycle.   The use of models illustrated in the previous example is typical of the modeling process as part of the overall scientific method. First, essential elements of the hypothesized role of interactions is summarized through mathematical equations. Second, mathematical analysis of the equations and numerical predictions allow a scientist to make predictions about the consequences of these interactions. Third, the predictions are interpreted in the context of the physical interaction. Ideally, these predictions are then followed up with a scientific experiment that directly tests the outcomes predicted by the analysis. If outcomes are different than predicted, then a modification of the original model is required, and the process repeats.  Mathematical models can be used to accomplish a variety of possible goals. One goal is to make quantitative predictions . By this, we mean that our model is expected to make predictions whose numerical values have direct interpretation in relation to observed relationships. The quality of the model is measured by how closely the model comes in predicting future observed relationships. An alternative goal is to make qualitative predictions . By this, we mean that our model is expected to provide structural predictions, such as the possibility for either a steady state behavior or a cyclic behavior in a system. The quality of the model is measured by how well the nature of the interactions going into the model provide an ability to understand how and when key structural features exist in a system, even if the numerical details are not in agreement with observable measurements.  So why might a scientist want to use a mathematical model? One obvious reason would simply be to make projections of future observations. Less obvious would be to repeatedly make projections of future observations under a variety of different possible conditions in order to identify optimal conditions. For example, when an experiment is expensive or ethically problematic to repeat many times, a mathematical model might inform a scientist which experimental conditions are most likely to provide meaningful insight. Similarly, a mathematical model might allow exploration of outcomes when there is no opportunity for repeated experimentation. You should recognize these objectives as corresponding to quantitative models.  A second reason for a mathematical model might not be concerned so much with precise prediction as understanding the significance of interactions. For example, in studying the spread of disease, public health policy makers might want to know which of several potential policies have the greatest potential in minimizing the impact of an impending outbreak. While a quantitative model might be desired, it may be adequate for the decision making process to understand basic trade-offs between different potential policies. Under such circumstances, a qualitative model may satisfy the needs of the scientists and policy makers.  "
},
{
  "id": "role-of-models-3",
  "level": "2",
  "url": "role-of-models.html#role-of-models-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "model model organism "
},
{
  "id": "role-of-models-6",
  "level": "2",
  "url": "role-of-models.html#role-of-models-6",
  "type": "Figure",
  "number": "1.2.1",
  "title": "",
  "body": "  Diagram illustrating the modeling cycle.  "
},
{
  "id": "role-of-models-8",
  "level": "2",
  "url": "role-of-models.html#role-of-models-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "quantitative predictions qualitative predictions "
},
{
  "id": "measurements",
  "level": "1",
  "url": "measurements.html",
  "type": "Section",
  "number": "1.3",
  "title": "Measurements",
  "body": " Measurements  To think more clearly about how models attempt to represent measurable quantities, we need to think more precisely about the nature of measurements and the state of a system. The most basic form of a measurement is a simple count. Population measurements are examples of counts, where we are interested in an actual number (integer) of individuals making up the total population. A population is an example of an extensive measurement . This means that if you take two different populations and bring them together, the total population is the sum of the parts. Other measurements quantify physical traits of an object or system, such as physical dimensions (length, area, volume), mass, temperature, or energy. As these physical measurements are not pure counts, they require a reference or standard of measurement.  Length and mass are additional examples of extensive attributes, and this is essential to the ability to measure them with reference to a standard unit of measure. Putting two lengths end-to-end creates a new length that is the sum of the parts. Putting two masses together creates a new mass that is the sum of the parts. So length can be measured according to a standard unit length . Essentially, one counts how many unit lengths (using a ruler) must be added together to obtain the total length represented by the object, including fractions of units. Using a ruler with different unit lengths leads to a different numerical measurement for the same length. Similarly, mass is measured by determining relative to a unit mass by counting how may units are required to obtain a total mass equivalent to the mass of the object, perhaps by using a balance. Using different standard units of mass results in different numerical measurements of the same mass.  In a sense, a population can also be thought of extensively in terms of a unit population size. Normally, we think of individuals as the standard unit. But it might be more practical to think in terms of hundreds or millions of individuals. In chemistry, populations consist of enormous numbers of atoms in terms of a standard unit called a mole which represents approximately (Avagadro's number) individual atoms.  Other quantities are known as intensive attributes . These are values where the measurement does not change when you have different amounts of a substance. Temperature is an example of an intensive attribute, because if you have two different amounts of a substance at the same temperature and combine them, the new amount of substance is larger but the temperature is the same. Similarly, the density of water (grams per liter) at a given temperature is the same regardless of how much water is present. Some subtlety does appear on occasion, such as when thinking about density of a gas, where combining two volumes of gas can result in density changes because of possible constraints on volume or pressure. However, intensive attributes do not simply add when combining amounts.  This leads us to the idea that we must distinguish between a measurement and a physical quantity. For example, the physical quantity might be a length. A measurement of that length provides us with a specific number, namely the number of units required to form the total length. While the quantity itself does not change when different units are used, the measurement does change.  For example, consider a meter stick. When measured with units of meters, the measurement is exactly 1. When measured with units of centimeters, the measurement is exactly 100, a different number. We can not say that since these are different numbers. To compare the measurements, we must include units, . That is, the quantity of length itself is represented as a measurement along with the units, written as an equation, or .  Basic mathematics works with pure numbers, not quantities with units. So as we think about applications of mathematics to physical problems, we must begin thinking about equations in terms of the physical quantities that are represented. Basic arithmetic operations of addition and subtraction can only work with quantities of the same basic type. For example, it is not appropriate to add a length to a mass. We can, however, add a length of 1 m to a length of 1 ft to create a new length of a total . Notice that the sum is not 2 since the units are not the same. To get a single measurement, we must express both quantities using a common unit.  Unit conversion is the process of expressing a quantity measured with respect to one unit in terms of a different unit. Mathematically, we think of unit conversion as simply multiplying by 1, formed from the ratio of measuring one unit in terms of another unit. For example, 1 inch is exactly 2.54 centimeters. So the ratio is exactly the pure number 1. If we need to convert a measurement from inches to centimeters, we will multiply by this ratio or its inverse. Units cancel much like variables, so we want to use the ratio such that the old units cancel leaving the new units.    Convert 15 inches to a measurement in centimeters.    To emphasize the use of the correct ratio, we show both the correct and incorrect ratios. Both equations are technically true, but only the equation where units cancel is actually useful. So the length of 15 inches is the same as the length of 38.1 centimeters.    The ratios that play a role in unit conversion are called unit conversion factors . Online search engines (like Google and Bing) have built in conversion tools for standard units. However, we will need to consider making conversions between non-standard units. Practicing with basic unit conversion is a practical skill toward understanding the process.  Finally, our last new vocabulary word is dimension , which refers to the type of quantity represented by a measurement, such as length , time , population , mass , etc. Two quantities can be added (or subtracted) or compared (inequalities or equations) only if they are the same dimension . In mathematical models, we often create individual terms that are products or ratios of several quantities. The dimension of the term is the corresponding product or ratio of the dimensions of the individual quantities.   A velocity is measured by finding the ratio of a distance traveled to the time taken. The distance traveled is a length , while the time taken is, simply, a time . So the dimension of velocity is a ratio of length to time .   We often represent a measured quantity with a symbol, such as a variable. When we wish to talk about the dimension of the quantity, we put square brackets around the variable. If is a variable representing a quantity, then is the symbol representing the dimension of the quantity. It is also convenient to have a symbolic representation of individual dimensions, which necessarily look like new variables but do not have a sense of quantity. Dimensional analysis, unfortunately, is not a frequent topic of discussion. Anytime you use dimensional analysis in your writing, you should explicitly explain all of your notation relating to dimensions.  To illustrate, consider velocity as discussed above. Let be the variable representing velocity (an actual quantity). We might use as a symbol representing the dimension of length (not an actual quantity of length, just the concept of length) and use as a symbol representing the dimension of time (also not an actual quantity of time, but the concept of time), then the dimension of is symbolically represented by . Our recognition that the dimension of velocity is the ratio of a length to a time is represented by the dimensional equation  Dimensional equations have no numerical interpretation. So a new velocity that is twice is still just a velocity (different value, but same dimension). So we can also say that     In physics, the kinetic energy of a mass (quantity) moving at a velocity (quantity) is computed as the formula . What is the dimension of energy?    We start by introducing symbolic representations of the elementary dimensions involved. So we represent the dimension of a length by , the dimension of a time by , and the dimension of a mass by . Recall that pure numbers do not affect a dimension. So we can create a dimensional equation    A quantity where all dimensions cancel is called dimensionless . Dimensionless quantities will play an important role in our analysis and interpretation of models. This is a rather lengthy discussion that will be broken into smaller pieces in future readings. For now, I'll simply point out that all of the basic mathematical functions (like exponentials, logarithms, sine, cosine, tangent, etc.) are defined only for numbers, so that in a model, they must be used in terms of dimensionless quantities.    The most basic model for population growth is exponential growth, where is the size of a population at a time , and and are coefficients determined by the population at two different times. What are the dimensions of and ?    As discussed above, the exponential is a pure number and the input (in this case, the quantity in the exponent), , must be dimensionless. There are two natural dimensions to this problem: the dimension for population which we represent by (number) and the dimension for time which we represent by . The dimension of the exponent is the product of the dimensions of and of , which must be dimensionless. We represent a dimensionless dimension with the number :   Consequently, we must have , so that has dimensions of the inverse of time. For example, a measurement of might be (read as 0.0693147 per year), which would correspond to a population that doubles every 10 years. Such unnatural units (per second, per year, etc.) take time to get used to. It helps to remember that the inverse unit simply reminds you that you need to multiply by a quantity with the ordinary dimension in order to achieve a dimensionless quantity. To finish the discussion, we need where . The mathematical quantity is dimensionless, , so that we must have . That is, represents an actual population size.      Start with the following basic relations between different measures of lengths: 1 foot = 12 inches, 1 yard = 3 feet, 1 mile = 1760 yards, 1 inch = 2.54 centimeters, 1 meter = 100 centimeters, and 1 kilometer = 1000 meters. Use conversion factors by hand (not online tools) to find equivalent distances as exact values.  1 ft = m  1 km = yd      30.48    100000\/91.44       Use conversion factors       Use conversion factors      If represents the dimension of a length, find the dimensions of each of the following geometric quantities.   The area of a rectangle with length and width is .  Then = .    The area of a circle with radius is .  Then = .    The volume of a rectangular box with side lengths , , and is given by .  Then = .    The volume of a circular cylinder with radius and height is given by .  Then = .    The volume of a sphere with radius is given by .  Then = .       L^2    L^3       The dimension of the area of a rectangle is .    Try using .       The dimension of the area of a circle is .    pi*L^2  Because is a pure number, and we use .    Use .       The dimension of the volume of a box is .    Try using .       The dimension of the volume of a cylinder is .    pi*L^3  Because is a pure number, and we use .    Try using .       The dimension of the volume of a sphere is .    4\/3*pi*L^3  Because is a pure number, and we use .    Try using .      "
},
{
  "id": "measurements-2",
  "level": "2",
  "url": "measurements.html#measurements-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "extensive measurement "
},
{
  "id": "measurements-3",
  "level": "2",
  "url": "measurements.html#measurements-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "unit length unit mass "
},
{
  "id": "measurements-5",
  "level": "2",
  "url": "measurements.html#measurements-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "intensive attributes "
},
{
  "id": "measurements-6",
  "level": "2",
  "url": "measurements.html#measurements-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "quantity measurement units "
},
{
  "id": "measurements-9",
  "level": "2",
  "url": "measurements.html#measurements-9",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Unit conversion "
},
{
  "id": "measurements-10",
  "level": "2",
  "url": "measurements.html#measurements-10",
  "type": "Example",
  "number": "1.3.1",
  "title": "",
  "body": "  Convert 15 inches to a measurement in centimeters.    To emphasize the use of the correct ratio, we show both the correct and incorrect ratios. Both equations are technically true, but only the equation where units cancel is actually useful. So the length of 15 inches is the same as the length of 38.1 centimeters.   "
},
{
  "id": "measurements-11",
  "level": "2",
  "url": "measurements.html#measurements-11",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "unit conversion factors "
},
{
  "id": "measurements-12",
  "level": "2",
  "url": "measurements.html#measurements-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "dimension "
},
{
  "id": "measurements-13",
  "level": "2",
  "url": "measurements.html#measurements-13",
  "type": "Example",
  "number": "1.3.2",
  "title": "",
  "body": " A velocity is measured by finding the ratio of a distance traveled to the time taken. The distance traveled is a length , while the time taken is, simply, a time . So the dimension of velocity is a ratio of length to time .  "
},
{
  "id": "measurements-15",
  "level": "2",
  "url": "measurements.html#measurements-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "dimensional equation "
},
{
  "id": "measurements-16",
  "level": "2",
  "url": "measurements.html#measurements-16",
  "type": "Example",
  "number": "1.3.3",
  "title": "",
  "body": "  In physics, the kinetic energy of a mass (quantity) moving at a velocity (quantity) is computed as the formula . What is the dimension of energy?    We start by introducing symbolic representations of the elementary dimensions involved. So we represent the dimension of a length by , the dimension of a time by , and the dimension of a mass by . Recall that pure numbers do not affect a dimension. So we can create a dimensional equation   "
},
{
  "id": "measurements-17",
  "level": "2",
  "url": "measurements.html#measurements-17",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "dimensionless "
},
{
  "id": "measurements-18",
  "level": "2",
  "url": "measurements.html#measurements-18",
  "type": "Example",
  "number": "1.3.4",
  "title": "",
  "body": "  The most basic model for population growth is exponential growth, where is the size of a population at a time , and and are coefficients determined by the population at two different times. What are the dimensions of and ?    As discussed above, the exponential is a pure number and the input (in this case, the quantity in the exponent), , must be dimensionless. There are two natural dimensions to this problem: the dimension for population which we represent by (number) and the dimension for time which we represent by . The dimension of the exponent is the product of the dimensions of and of , which must be dimensionless. We represent a dimensionless dimension with the number :   Consequently, we must have , so that has dimensions of the inverse of time. For example, a measurement of might be (read as 0.0693147 per year), which would correspond to a population that doubles every 10 years. Such unnatural units (per second, per year, etc.) take time to get used to. It helps to remember that the inverse unit simply reminds you that you need to multiply by a quantity with the ordinary dimension in order to achieve a dimensionless quantity. To finish the discussion, we need where . The mathematical quantity is dimensionless, , so that we must have . That is, represents an actual population size.   "
},
{
  "id": "ex-measure-distance-conversions",
  "level": "2",
  "url": "measurements.html#ex-measure-distance-conversions",
  "type": "Exercise",
  "number": "1.3.1",
  "title": "",
  "body": " Start with the following basic relations between different measures of lengths: 1 foot = 12 inches, 1 yard = 3 feet, 1 mile = 1760 yards, 1 inch = 2.54 centimeters, 1 meter = 100 centimeters, and 1 kilometer = 1000 meters. Use conversion factors by hand (not online tools) to find equivalent distances as exact values.  1 ft = m  1 km = yd      30.48    100000\/91.44       Use conversion factors       Use conversion factors    "
},
{
  "id": "ex-measure-geometric-dimensions",
  "level": "2",
  "url": "measurements.html#ex-measure-geometric-dimensions",
  "type": "Exercise",
  "number": "1.3.2",
  "title": "",
  "body": " If represents the dimension of a length, find the dimensions of each of the following geometric quantities.   The area of a rectangle with length and width is .  Then = .    The area of a circle with radius is .  Then = .    The volume of a rectangular box with side lengths , , and is given by .  Then = .    The volume of a circular cylinder with radius and height is given by .  Then = .    The volume of a sphere with radius is given by .  Then = .       L^2    L^3       The dimension of the area of a rectangle is .    Try using .       The dimension of the area of a circle is .    pi*L^2  Because is a pure number, and we use .    Use .       The dimension of the volume of a box is .    Try using .       The dimension of the volume of a cylinder is .    pi*L^3  Because is a pure number, and we use .    Try using .       The dimension of the volume of a sphere is .    4\/3*pi*L^3  Because is a pure number, and we use .    Try using .    "
},
{
  "id": "system-state",
  "level": "1",
  "url": "system-state.html",
  "type": "Section",
  "number": "1.4",
  "title": "The State of a System",
  "body": "> The State of a System  When we use the word system , we are referring to the subject of study and all of the possible quantities associated with that subject. In principle, every object interacts with so many other objects that a system’s complexity would be incomprehensible. For the sake of simplification and sanity, we adopt a reductionist viewpoint and consider the system as representing only those quantities that are relevant for addressing specific scientific questions.  A state variable is any individual quantity associated with the subject of study. A state variable might represent a quantity that could be directly measured (even if it is not being measured). It might also represent a mathematical expression derived from other measurements, in which case the state variable is called a dependent variable . For example, a physical object has a mass, , as well as a volume, . Both and are measurable. Using these state variables, we can also consider the average density, , which is a dependent variable.  The state of the system is the collection of all state variables, simultaneously measured for a given configuration of the system. In many cases, the system is time-dependent , meaning that the state of the system naturally is changing as time passes. In this case, the time of measurement should be included as one of the state variables. Practically, we only include the state variables that are directly relevant.  We often represent a variable by a symbol a letter, a Greek letter, an abbreviation, or even a word. That symbol becomes a name for the variable to be used in sentences, expressions, and equations. Uppercase and lowercase letters are different symbols and should not be interchanged with one another. The choice of symbol should generally be related to the meaning of the variable. An important part of communication in modeling is in stating clearly the variables of a system and identifying the symbols that are chosen to represent them.   Consider a population being studied at a certain location. Some of the state variables include the number of individuals in the population, the number of births and the number of deaths during a given time period (e.g., for a year), the total biomass of the population, the physical area required to support the population, and the amount of food used to feed the population during the time period. The state of the population consists of all of these measurements for a given time. The same population under study will have different states at different times.  When discussing these state variables, we might want to assign variable symbols. We might choose to represent the number of individuals in the population, where the letter was chosen as the first letter in the word population . We might use and to represent the number of births and deaths, respectively, for a similar reason, although we would need to specify the time frame under consideration since these are recorded over an interval of time rather than at a fixed time. Since biomass also starts with the letter B , we might be tempted to use the same variable, but we should choose something distinct, such as for mass. The amount of food consumed during an interval might be represented by , and the area physically occupied by the population might be represented by .  When communicating to others our variable choices, we do not need to provide the reasoning for our choice, but we do need to communicate the results. We might create an explanatory figure or table listing the variables and what they measure. The previous paragraph would not normally appear in written work, but a paragraph such as the following might be typical.  We let represent the size of the population, and let and represent the number of births and deaths, respectively, during the preceding time interval. We let measure the physical area occupied by the population and use to represent the total biomass of the population. Finally, we use for the amount of food consumed by the population in the preceding time interval.   The next example introduces some particular data that we will use for additional exploration of the ideas in this section.   Consider the following data about the population, births and deaths in the United States. To conserve space, the data are given using scientific notation expressed in the standard machine form where the power of 10 follows the letter E, so that would be written 2.521E8.            Year  Population  Births  Deaths   Year  Population  Births  Deaths    1991  2.521E8  4.111E6  2.170E6   2001  2.850E8  4.026E6  2.416E6    1992  2.550E8  4.065E6  2.176E6   2002  2.876E8  4.022E6  2.443E6    1993  2.577E8  4.000E6  2.269E6   2003  2.901E8  4.090E6  2.448E6    1994  2.602E8  3.953E6  2.279E6   2004  2.928E8  4.112E6  2.397E6    1995  2.628E8  3.900E6  2.312E6   2005  2.955E8  4.138E6  2.448E6    1996  2.652E8  3.891E6  2.315E6   2006  2.984E8  4.266E6  2.426E6    1997  2.677E8  3.881E6  2.314E6   2007  3.012E8  4.316E6  2.424E6    1998  2.703E8  3.942E6  2.337E6   2008  3.041E8  4.248E6  2.472E6    1999  2.727E8  3.959E6  2.391E6   2009  3.068E8  4.131E6  2.437E6    2000  2.822E8  4.059E6  2.403E6   2010  3.094E8  3.999E6  2.468E6    Each row (corresponding to the population in a given year) represents a distinct state of the system. The state variables for our population include , the year of the observation, , the population at the beginning of the indicated year, , the total number of births recorded during that year, and , the total number of deaths recorded during the year. We will also introduce a calculated variable with , so that corresponds to the year . This is done for convenience so that the numbers used when thinking about time are smaller in magnitude.   Note that symbols are different than letters. We think of B and b as both representing the same letter in the alphabet. However, they are different symbols . So if we declare that our state variables are represented using variables , , , and , we should not use , , or as those are different symbols and do not have a stated interpretation.  One of the primary purposes of mathematical modeling is to establish relationships between different state variables and then use those relationships to make predictions. Plotting graphs of relationships between variables often reveal patterns. We usually use scatter plots to look for these relationships. A scatter plot takes two state variables which we measure relative to corresponding units (in order to get numbers), say and . We then plot the points coming from different states. If a pattern arises, then we look for an equation that captures the essential features of the relationship. These equations form the essence of our mathematical model. We can then analyze our system equations to see what predictions they allow us to infer.  "
},
{
  "id": "system-state-2",
  "level": "2",
  "url": "system-state.html#system-state-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "system "
},
{
  "id": "system-state-3",
  "level": "2",
  "url": "system-state.html#system-state-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "state variable dependent variable "
},
{
  "id": "system-state-4",
  "level": "2",
  "url": "system-state.html#system-state-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "state time-dependent "
},
{
  "id": "system-state-6",
  "level": "2",
  "url": "system-state.html#system-state-6",
  "type": "Example",
  "number": "1.4.1",
  "title": "",
  "body": " Consider a population being studied at a certain location. Some of the state variables include the number of individuals in the population, the number of births and the number of deaths during a given time period (e.g., for a year), the total biomass of the population, the physical area required to support the population, and the amount of food used to feed the population during the time period. The state of the population consists of all of these measurements for a given time. The same population under study will have different states at different times.  When discussing these state variables, we might want to assign variable symbols. We might choose to represent the number of individuals in the population, where the letter was chosen as the first letter in the word population . We might use and to represent the number of births and deaths, respectively, for a similar reason, although we would need to specify the time frame under consideration since these are recorded over an interval of time rather than at a fixed time. Since biomass also starts with the letter B , we might be tempted to use the same variable, but we should choose something distinct, such as for mass. The amount of food consumed during an interval might be represented by , and the area physically occupied by the population might be represented by .  When communicating to others our variable choices, we do not need to provide the reasoning for our choice, but we do need to communicate the results. We might create an explanatory figure or table listing the variables and what they measure. The previous paragraph would not normally appear in written work, but a paragraph such as the following might be typical.  We let represent the size of the population, and let and represent the number of births and deaths, respectively, during the preceding time interval. We let measure the physical area occupied by the population and use to represent the total biomass of the population. Finally, we use for the amount of food consumed by the population in the preceding time interval.  "
},
{
  "id": "ex-US-population-data",
  "level": "2",
  "url": "system-state.html#ex-US-population-data",
  "type": "Example",
  "number": "1.4.2",
  "title": "",
  "body": " Consider the following data about the population, births and deaths in the United States. To conserve space, the data are given using scientific notation expressed in the standard machine form where the power of 10 follows the letter E, so that would be written 2.521E8.            Year  Population  Births  Deaths   Year  Population  Births  Deaths    1991  2.521E8  4.111E6  2.170E6   2001  2.850E8  4.026E6  2.416E6    1992  2.550E8  4.065E6  2.176E6   2002  2.876E8  4.022E6  2.443E6    1993  2.577E8  4.000E6  2.269E6   2003  2.901E8  4.090E6  2.448E6    1994  2.602E8  3.953E6  2.279E6   2004  2.928E8  4.112E6  2.397E6    1995  2.628E8  3.900E6  2.312E6   2005  2.955E8  4.138E6  2.448E6    1996  2.652E8  3.891E6  2.315E6   2006  2.984E8  4.266E6  2.426E6    1997  2.677E8  3.881E6  2.314E6   2007  3.012E8  4.316E6  2.424E6    1998  2.703E8  3.942E6  2.337E6   2008  3.041E8  4.248E6  2.472E6    1999  2.727E8  3.959E6  2.391E6   2009  3.068E8  4.131E6  2.437E6    2000  2.822E8  4.059E6  2.403E6   2010  3.094E8  3.999E6  2.468E6    Each row (corresponding to the population in a given year) represents a distinct state of the system. The state variables for our population include , the year of the observation, , the population at the beginning of the indicated year, , the total number of births recorded during that year, and , the total number of deaths recorded during the year. We will also introduce a calculated variable with , so that corresponds to the year . This is done for convenience so that the numbers used when thinking about time are smaller in magnitude.  "
},
{
  "id": "system-state-10",
  "level": "2",
  "url": "system-state.html#system-state-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "scatter plots "
},
{
  "id": "sec-mm-intro-ggplot",
  "level": "1",
  "url": "sec-mm-intro-ggplot.html",
  "type": "Section",
  "number": "1.5",
  "title": "Introducing tidyverse and ggplot",
  "body": " Introducing tidyverse and ggplot  In this course, we will be learning to use R and the tidyverse set of packages for our data visualization. So-called tidy data is organized in tables where each state variable is a column, and each row is the collection of the values for all state variables for a given experimental state. These tables are often put together in a spreadsheet. We will learn to deal with tables that have been exported as csv files, which stands for comma-separated values . Our data should be organized to have only contain one table per file. The data introduced in is a subset of the data found in .  We will import the US population data into R and visualize different relationships between the state variables. When data files are not too large, it is often convenient to open them directly in a spreadsheet application to see how the file is organized. The first 10 rows of the US population data file are illustrated in .   Import of US-population-data.csv in Microsoft Excel    Notice in this file that there are several lines describing the data. This is called metadata and contains information about the data but that are not actually part of the data. Often, metadata is stored in a companion file associated with our data files. The metadata is not part of our desired import, so we will want to skip the first five (5) lines of the file. The sixth row contains the names of our state variables, and the data begin in the seventh row.  We will import the data into R using the read_csv function. Open RStudio and create a new project. If you are working on your own computer, you can have as many different projects as you desire. If you are working with RStudio on posit.cloud, then your license imposes a limit to the number of projects, and you may wish to use a project for multiples examples. Since this is our first example, we will illustrate the process using a project for data visualization associated with the course.   I named my project mathbio-data-visualization and downloaded the data file to be saved in the resulting folder.   If you click on the data file, you have the option of viewing the file or importing the data set. We will import the data set. An import wizard page opens showing you the import options. In the corner of the wizard is the R code that we will use. Using code has the important consequence of allowing us to create reproducible analysis processes. If we want to come back and repeat our work, a saved sequence of code will allow us to know exactly what we did the last time.   As we noted earlier, we want to skip the first five rows of metadata. One of the wizard options is an option Skip to indicate how many rows are skipped, and we type 5 . Notice that once we do this, the wizard anticipates how our data is structured. We are given a chance to set the Name of our imported table, but the default value of US_population_data seems completely adequate. There is another option First Row as Names that was selected by default. The option Open Data Viewer will cause RStudio to open a table viewer after import that will give us a spreadsheet-like view of the resulting import. This is useful for our initial exploration, but we will not include that in our final script.   library(readr) US_population_data <- read_csv(\"US-population-data.csv\", skip = 5)   The function that does the import work is named read_csv . Most functions in R are defined in various packages called libraries . Before we can use read_csv , we first need to unpack the readr library where the function was defined. The inputs , which are called arguments , to the function are listed between parentheses that immediately follow the function name and separated by commas. The first argument is the name of the data file. The read_csv had many other optional settings, one of which was skip , so when the code specifies that value, the name of the option is given where the code says skip = 5 . Once this code has been evaluated, we can access the data table, which is now a structure called tibble , using the name US_population_data .  To create a graph, we will use another of the tidyverse libraries called ggplot2 that provides a graphing function ggplot . The first argument of ggplot , which creates a graphical object, is the data-frame or tibble containing our state variables. The attributes of this graphical object consist of aesthetic elements, such as titles and axes, and informative geometric objects that represent the data. It is common to define many of the aesthetic elements in the call to ggplot , by adding a mapping argument which creates connections (maps) between elements of the graph and our chosen features.  When creating graphs of individual relationships between state variables, the -axis and -axis correspond to specific variables. Consequently, one common mapping connects the axes to specific variables in the data-frame or tibble. If we wanted to create a graph with Year on the -axis and Population on the -axis, we would include the aesthetic assignment mapping = aes(x = Year, y = Population) . In addition, we need to add a geometric representation of our data, which for a scatterplot are points representing values from our state variables. Such a graph would be created from the commands shown in the following listing.   library(ggplot2) # Only required before our first use of ggplot ggplot(US_population_data, mapping = aes(x = Year, y = Population) ) + geom_point()    What do we notice about this graph? One thing is that we have much more data than the original data in our earlier table. The data file just contained many more years than the original table shown in the text. We would like to restrict our focus on the more narrow range of years. Secondly, we might notice that the -axis range was chosen to give a good spread of our data but does not properly represent size as the value is not on the axis. We might want to know how to force the axis to set a scale of our choosing. Thirdly, we would like to add some color to the graph.  The second and third changes come by adding additional information to the graphical object. Because we are assigning a color to the geometric points, we can add that information as an optional argument to geom_point . (Later we will have a desire to assign color based on other features and that will involve a different strategy.) Assigning limits to the axes correspond to functions xlim and ylim .   ggplot(US_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + ylim(0, 4e8)    The other requested change actually represents a desire to analyze a subset of the original data. While we might graphically get the result of interest by adding xlim(1991,2010) , we will be more authentic to our intent by creating a restricted data set. The library dplyr contains a function filter that accomplishes this important feat. Using a smaller data set, we also adjust the maximum value of the -axis.   library(dplyr) focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + ylim(0, 3.5e8)    We might want to look at the other data values so that we can see how the number of births and deaths are related to the size of the population. One approach to accomplish this is to add two new geometric objects. Because the -values of these new objects do not come from Population , the geometric objects will add aesthetic updates to use Births and Deaths .   ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + geom_point(aes(y = \"Births\"), color = \"red\") + geom_point(aes(y = \"Deaths\"), color = \"green\") + ylim(0, 3.5e8)    Because the number of births and deaths are just a small fraction of the size of the total population, the graphs for births and deaths are hard to visualize and nearly overlap one another in the figure. A common strategy for visualizing graphs where different data points have very different orders of magnitude is to use a logarithmic scale. We can update our graph to use a logarithmic scale by adding the option scale_y_log10 in place of the fixed axes ylim . While we are at it, let us distinguish the points by using different shapes (see .   ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\", shape = 15) + geom_point(aes(y = Births), color = \"green\", shape = 16) + geom_point(aes(y = Deaths), color = \"red\", shape = 17) + scale_y_log10()    Curiously, the approach outlined above is not the recommended approach. We will take a quick side-trip to discuss an alternative approach. In reality, our graph consists of points all of the form where the -value is a year and the -value is either a population size, a number of births, or a number of deaths. It is cleaner to take our data and create a new data set with just two columns, say Year and Count , with a new classification column Count_Type (spaces are problematic) that indicates which data point is being represented. The graphing tool then will run through a single geometric object but can provide different styling options based on the classification of the points. A nice side-effect of adopting this new strategy is that we get easy legends for our plot.  The restructuring of our data is completed with the use of a command pivot_longer (make the table longer by moving columns into extra rows), defined in the tidyr library. This restructured data is temporary, so we can pass it through to the ggplot command using a pipe , represented by the operator |> . A pipe takes the output of one function ( pivot_longer ) and passes it directly into the input of the next function ( ggplot ). In our aesthetics, we assign both color and shape to look at the Count_Type column, so that each type is automatically assigned a unique color and shape.   library(tidyr) pivot_longer(focus_population_data, cols = !Year, # every column *but* Year into separate rows names_to = \"Count_Type\", values_to = \"Count\" ) |> ggplot(mapping = aes(x = Year, y = Count, color = Count_Type, shape = Count_Type) ) + geom_point() + scale_y_log10()    Putting all of this together into a single block, we have a repeatable script that will generate the plot of interest. Note that we commonly put all of the libraries at the top of the script. Comments help us remember why we did steps.   library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (filter) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Load the data from a file US_population_data <- read_csv(\"US-population-data.csv\", skip = 5) # Focus on the the years 1991-2010 focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) # Reorganize to plot Births, Deaths, Population vs Year pivot_longer(focus_population_data, cols = !Year, # every column *but* Year into separate rows names_to = \"Count_Type\", values_to = \"Count\" ) |> # And pipe the resulting frame into ggplot ggplot(mapping = aes(x = Year, y = Count, color = Count_Type, shape = Count_Type) ) + geom_point() + scale_y_log10()   "
},
{
  "id": "fig-US-population-data-in-spreadsheet",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#fig-US-population-data-in-spreadsheet",
  "type": "Figure",
  "number": "1.5.1",
  "title": "",
  "body": " Import of US-population-data.csv in Microsoft Excel   "
},
{
  "id": "sec-mm-intro-ggplot-5",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#sec-mm-intro-ggplot-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "metadata "
},
{
  "id": "sec-mm-intro-ggplot-10",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#sec-mm-intro-ggplot-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "reproducible "
},
{
  "id": "listing-US-popn-import",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-import",
  "type": "Listing",
  "number": "1.5.2",
  "title": "",
  "body": " library(readr) US_population_data <- read_csv(\"US-population-data.csv\", skip = 5)  "
},
{
  "id": "sec-mm-intro-ggplot-14",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#sec-mm-intro-ggplot-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "packages libraries arguments "
},
{
  "id": "listing-US-popn-population-v-time-first",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-first",
  "type": "Listing",
  "number": "1.5.3",
  "title": "",
  "body": " library(ggplot2) # Only required before our first use of ggplot ggplot(US_population_data, mapping = aes(x = Year, y = Population) ) + geom_point()  "
},
{
  "id": "listing-US-popn-population-v-time-second",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-second",
  "type": "Listing",
  "number": "1.5.4",
  "title": "",
  "body": " ggplot(US_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + ylim(0, 4e8)  "
},
{
  "id": "listing-US-popn-population-v-time-third",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-third",
  "type": "Listing",
  "number": "1.5.5",
  "title": "",
  "body": " library(dplyr) focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + ylim(0, 3.5e8)  "
},
{
  "id": "listing-US-popn-population-v-time-four",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-four",
  "type": "Listing",
  "number": "1.5.6",
  "title": "",
  "body": " ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\") + geom_point(aes(y = \"Births\"), color = \"red\") + geom_point(aes(y = \"Deaths\"), color = \"green\") + ylim(0, 3.5e8)  "
},
{
  "id": "listing-US-popn-population-v-time-five",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-five",
  "type": "Listing",
  "number": "1.5.7",
  "title": "",
  "body": " ggplot(focus_population_data, mapping = aes(x = Year, y = Population) ) + geom_point(color = \"blue\", shape = 15) + geom_point(aes(y = Births), color = \"green\", shape = 16) + geom_point(aes(y = Deaths), color = \"red\", shape = 17) + scale_y_log10()  "
},
{
  "id": "sec-mm-intro-ggplot-33",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#sec-mm-intro-ggplot-33",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pipe "
},
{
  "id": "listing-US-popn-population-v-time-six",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-six",
  "type": "Listing",
  "number": "1.5.8",
  "title": "",
  "body": " library(tidyr) pivot_longer(focus_population_data, cols = !Year, # every column *but* Year into separate rows names_to = \"Count_Type\", values_to = \"Count\" ) |> ggplot(mapping = aes(x = Year, y = Count, color = Count_Type, shape = Count_Type) ) + geom_point() + scale_y_log10()  "
},
{
  "id": "listing-US-popn-population-v-time-final",
  "level": "2",
  "url": "sec-mm-intro-ggplot.html#listing-US-popn-population-v-time-final",
  "type": "Listing",
  "number": "1.5.9",
  "title": "",
  "body": " library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (filter) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Load the data from a file US_population_data <- read_csv(\"US-population-data.csv\", skip = 5) # Focus on the the years 1991-2010 focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) # Reorganize to plot Births, Deaths, Population vs Year pivot_longer(focus_population_data, cols = !Year, # every column *but* Year into separate rows names_to = \"Count_Type\", values_to = \"Count\" ) |> # And pipe the resulting frame into ggplot ggplot(mapping = aes(x = Year, y = Count, color = Count_Type, shape = Count_Type) ) + geom_point() + scale_y_log10()  "
},
{
  "id": "sec-mm-variable-relations",
  "level": "1",
  "url": "sec-mm-variable-relations.html",
  "type": "Section",
  "number": "1.6",
  "title": "Relations between Variables",
  "body": " Relations between Variables  In the previous section, we explored the US census population data set as the variables of Births , Deaths , and Populations changed with Year . Mathematical models are often built by exploring the relations between the state variables themselves other than time. How do birth and death rates relate to the population size? We can start to visualize this by creating a plot.  We will work with the same data file . Using the same basic pattern as the previous work, we will load the data into R using read_csv and then restrict to the years of interest using filter . This time we will want to be plotting points where -values correspond to the Population values and -values correspond to the Births and Deaths . As there are two distinct types of -values, we will again use pivot_longer to create a tidy version of the data for plotting.   library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (filter) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Load the data from a file US_population_data <- read_csv(\"US-population-data.csv\", skip = 5) # Focus on the the years 1991-2010 focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) # Reorganize to plot Births, Deaths vs Population pivot_longer(focus_population_data, cols = c(Births, Deaths), # these columns get separate rows names_to = \"Rate_Type\", # category column values_to = \"Rate\" # column for actual values ) |> # And pipe the resulting frame into ggplot ggplot(mapping = aes(x = Population, y = Rate, color = Rate_Type, shape = Rate_Type) ) + geom_point()    From the resulting figure, we can see that the birth rate goes up and down in an unusual manner. This is typical in human populations, where birth rates are affected significantly by socioeconomic and political conditions. The death rate on the other hand appears to steadily increase with an increase in the population size. So we will spend some time in this section exploring that relationship.  The simplest models for relationships are constant and linear relations. Let us look at the possibility of a linear relation between the death rate and the population size. We can add a best-fit line to our data and see what it looks like. The following script assumes that we have already imported the data as shown in the previous listing. Because we are looking at just the Deaths for -values, we will revert back to the original data structure.   ggplot(focus_population_data, mapping = aes(x = Population, y = Deaths) ) + geom_point(color = \"green\") + geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE)   The geometric object that was added is geom_smooth , which has several different methods. The method we used is lm which stands for linear model . The associated formula option indicates that we want a linear model where is a linear function of . The option se = FALSE indicates that we do not want to include the standard error as part of our linear model. Change this to TRUE to see the effect, which essentially shows how much confidence we have that given the data, a linear model would be predicting a linear model values.  Adding the graph of the line does not show us the formula for the model. We need to make a new call to find the values. Before introducing the command, recall that the standard high school representation of a line uses the form , where is the slope of the line and is the -intercept, meaning the point is on the line. The symbols and , although common, are not actually standard. For example, in physics, more commonly refers to mass . We could instead use a model , and with this representation, is the -intercept and is the slope.  In R, the method that we use to find the best linear model is lm . The first argument is formula , which wants to know which columns in our data are related. The dependent variable goes on the left of the formula. The right side of the formula is going to be a sum of columns that each are included with their individual slope terms. And the two sides of the formula are connected with a tilde symbol ~ . In our example, we want a model Deaths ~ Population because we want to predict Deaths (dependent variable) as a linear function of Population (explanatory or independent variable). The result of our call will be a structure that gives an intercept and a coefficient for Population . (Results are shown following the code that you input.)   lm(formula = Deaths ~ Population, data = focus_population_data)   Call: lm(formula = Deaths ~ Population, data = focus_population_data) Coefficients: (Intercept) Population 9.160e+05 5.215e-03    The results of the linear model calculation tell us that the intercept is 9.160e+05 and the coefficient for Population is 5.215e-03. Using these values in the equation of a line, and using for Population and for Deaths , we get a model equation   Another very important linear model is a proportional model. This corresponds to a linear model where the intercept is required to be 0. The equation is a linear model but is not proportional. The equation , or more simply , is a proportional model. We can find the best proportinal model using lm by using a formula with structure y ~ 0 + x , and by explicitly adding 0 , we force the intercept value to be 0 and then find the best matching slope coefficients. The following listing shows that our best proportional regression model would be given by    lm(formula = Deaths ~ 0 + Population, data = focus_population_data)   Call: lm(formula = Deaths ~ 0 + Population, data = focus_population_data) Coefficients: Population 0.008455    What do we do about other models? For example, can we find the best quadratic model? Some tools, like , make this very easy. R, which was written as a statistical software package, was designed to work with data sets and not formulas. However, we can work around this quite easily.  If our data set has multiple explanatory variables , , and for a dependent variable , the generalization of a simiple linear model takes the form . We still have an intercept along with separate slope coefficients for each of the explanatory variables. To find the best fit model of this form, we would use formula = Y ~ X1 + X2 + X3 .  To get models like quadratics or other polynomials, we can find the coefficients we need by engineering new columns in our data set. For example, a quadratic model for our death rate would have the form . Our data set already has a column for with Population . We need to generate a new column containing . The function that adds new calculated columns is mutate command in the dplyr library. We will use the pipe method to illustrate the steps we need.   expand_data <- focus_population_data |> # Start with our data select(P = Population, D = Deaths) |> # Keep only P and D mutate(P2 = P^2) # Add column for P^2 lm(formula = D ~ P + P2, data = expand_data)   Call: lm(formula = D ~ P + P2, data = expand_data) Coefficients: (Intercept) P P2 -9.163e+06 7.684e-02 -1.269e-10    As a result of this calculation, our best quadratic model given the data is given by the model .  As you can see, the summary of our calculation only gave four significant digits to each of the coefficients. When working with population sizes on the order of (hundreds of millions), small changes in the coefficients can result in fairly noticable differences in calculated values. If we want to have more digits, we need to look at the returned structure directly and not just the summary that is provided by the call. Assign a name to the result of the lm call and then examine the coefficients stored in the result.   D_model <- lm(formula = D ~ P + P2, data = expand_data) D_model$coefficients   (Intercept) P P2 -9.163022e+06 7.683889e-02 -1.268641e-10    Again, because R was not designed to work with formulas but with data, there is not an automatic method to draw the curve we want based on this best quadratic fit. We need to know how to graph a function instead of data. The graph of a continuous function can be approximated by using a sequence of calculated points connected together to form a curve. Our task is to do the following:  Identify our domain interval,  Create a sequence of -values from that interval,  Use formula to calculate -values for each point,  Graph the calculated points connected.  We will first generate a graph without trying to connect it to our data.   # Create the sequence of x-values x_vals <- seq(from = 2.55e8, to = 3.10e8, length.out = 50) # Extract the coefficients for an easier name to calculate the y-values c <- D_model$coefficients y_vals <- c[1] + c[2] * x_vals + c[3] * x_vals^2 # Put the data in a table and pipe the result to ggplot tibble(P = x_vals, D = y_vals) |> ggplot(mapping = aes(x = P, y = D)) + geom_path(color = \"blue\", linewidth = 2)    In order to combine graphs that come from different data sets, we will create geometric layers resulting from different data features. This means that when we open up our graphics layout using ggplot , we should not pass a common dataset for all of the layers. Instead, we pass an empty dataset indicator NULL . We can still name our axes in the aesthetics. Then when we generate the geometric layers, we will specify our datasets and indicate the columns for in each case separately.   ggplot(data = NULL, mapping = aes(x = Population, y = Deaths)) + geom_point(data = focus_population_data, aes(x = Population, y = Deaths), color = \"blue\", shape = 16) + geom_path(data = tibble(P = x_vals, D = y_vals), aes(x = P, y = D), color = \"violet\", linewidth = 1)    Next, we want to look at derived state variables. (Note: derived means generated from and is not related to the calculus idea of derivative .) For populations, we are often interested in per capita rates , which are calculated by taking a total rate (like a birth rate or death rate) and dividing it by the population size. This gives the number of births or deaths per year per individual .  We add new columns to our dataset using mutate to represent these new values. Let's take a look at how per capita birth and death rates relate to population size.   focus_population_data |> mutate(Births_per_capita = Births \/ Population, Deaths_per_capita = Deaths \/ Population) |> pivot_longer(cols = c(Births_per_capita, Deaths_per_capita), names_to = \"rate_name\", values_to = \"per_capita_rate\") |> ggplot(mapping = aes(x = Population, y = per_capita_rate, color = rate_name, shape = rate_name)) + geom_point()    This new view suggests that perhaps the population saw a transition in per capita birth rates for a time and then settled down to something approximately constant around 0.014 (births per individual per year), or 14 births per year per thousand individuals. The per capita death rate possibly was seeing a gradual decline. Because death rates are based on economics as well as medical innovations, we are unlikely going to want to attribute the falling death rate to the increasing population. However, from a modeling perspective, we could ignore this good sense and determine what the relationship is if we wanted to attribute all of the change to population size.   work_data <- focus_population_data |> mutate(Births_per_capita = Births \/ Population, Deaths_per_capita = Deaths \/ Population) death_pc_model <- lm(formula = Deaths_per_capita ~ Population, data = work_data) death_pc_model$coefficients ggplot(data = work_data, mapping = aes(x = Population, y = Deaths_per_capita)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE)   (Intercept) Population 1.164158e-02 -1.123642e-11     "
},
{
  "id": "listing-US-popn-rates-vs-population-1",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-US-popn-rates-vs-population-1",
  "type": "Listing",
  "number": "1.6.1",
  "title": "",
  "body": " library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (filter) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Load the data from a file US_population_data <- read_csv(\"US-population-data.csv\", skip = 5) # Focus on the the years 1991-2010 focus_population_data <- filter(US_population_data, Year >= 1991 & Year < 2010) # Reorganize to plot Births, Deaths vs Population pivot_longer(focus_population_data, cols = c(Births, Deaths), # these columns get separate rows names_to = \"Rate_Type\", # category column values_to = \"Rate\" # column for actual values ) |> # And pipe the resulting frame into ggplot ggplot(mapping = aes(x = Population, y = Rate, color = Rate_Type, shape = Rate_Type) ) + geom_point()  "
},
{
  "id": "listing-US-popn-rates-vs-population-2",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-US-popn-rates-vs-population-2",
  "type": "Listing",
  "number": "1.6.2",
  "title": "",
  "body": " ggplot(focus_population_data, mapping = aes(x = Population, y = Deaths) ) + geom_point(color = \"green\") + geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE)  "
},
{
  "id": "listing-lm-deaths-vs-population",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-lm-deaths-vs-population",
  "type": "Listing",
  "number": "1.6.3",
  "title": "",
  "body": " lm(formula = Deaths ~ Population, data = focus_population_data)   Call: lm(formula = Deaths ~ Population, data = focus_population_data) Coefficients: (Intercept) Population 9.160e+05 5.215e-03   "
},
{
  "id": "sec-mm-variable-relations-14",
  "level": "2",
  "url": "sec-mm-variable-relations.html#sec-mm-variable-relations-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "proportional "
},
{
  "id": "listing-lm-deaths-vs-population-proportional",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-lm-deaths-vs-population-proportional",
  "type": "Listing",
  "number": "1.6.4",
  "title": "",
  "body": " lm(formula = Deaths ~ 0 + Population, data = focus_population_data)   Call: lm(formula = Deaths ~ 0 + Population, data = focus_population_data) Coefficients: Population 0.008455   "
},
{
  "id": "sec-mm-variable-relations-18",
  "level": "2",
  "url": "sec-mm-variable-relations.html#sec-mm-variable-relations-18",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pipe "
},
{
  "id": "listing-lm-deaths-vs-population-quadratic",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-lm-deaths-vs-population-quadratic",
  "type": "Listing",
  "number": "1.6.5",
  "title": "",
  "body": " expand_data <- focus_population_data |> # Start with our data select(P = Population, D = Deaths) |> # Keep only P and D mutate(P2 = P^2) # Add column for P^2 lm(formula = D ~ P + P2, data = expand_data)   Call: lm(formula = D ~ P + P2, data = expand_data) Coefficients: (Intercept) P P2 -9.163e+06 7.684e-02 -1.269e-10   "
},
{
  "id": "listing-lm-deaths-vs-population-quadratic-2",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-lm-deaths-vs-population-quadratic-2",
  "type": "Listing",
  "number": "1.6.6",
  "title": "",
  "body": " D_model <- lm(formula = D ~ P + P2, data = expand_data) D_model$coefficients   (Intercept) P P2 -9.163022e+06 7.683889e-02 -1.268641e-10   "
},
{
  "id": "listing-qm-graph-function",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-qm-graph-function",
  "type": "Listing",
  "number": "1.6.7",
  "title": "",
  "body": " # Create the sequence of x-values x_vals <- seq(from = 2.55e8, to = 3.10e8, length.out = 50) # Extract the coefficients for an easier name to calculate the y-values c <- D_model$coefficients y_vals <- c[1] + c[2] * x_vals + c[3] * x_vals^2 # Put the data in a table and pipe the result to ggplot tibble(P = x_vals, D = y_vals) |> ggplot(mapping = aes(x = P, y = D)) + geom_path(color = \"blue\", linewidth = 2)  "
},
{
  "id": "listing-qm-combining-graphs",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-qm-combining-graphs",
  "type": "Listing",
  "number": "1.6.8",
  "title": "",
  "body": " ggplot(data = NULL, mapping = aes(x = Population, y = Deaths)) + geom_point(data = focus_population_data, aes(x = Population, y = Deaths), color = \"blue\", shape = 16) + geom_path(data = tibble(P = x_vals, D = y_vals), aes(x = P, y = D), color = \"violet\", linewidth = 1)  "
},
{
  "id": "sec-mm-variable-relations-29",
  "level": "2",
  "url": "sec-mm-variable-relations.html#sec-mm-variable-relations-29",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "per capita rates "
},
{
  "id": "listing-US-per-capita-rates-01",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-US-per-capita-rates-01",
  "type": "Listing",
  "number": "1.6.9",
  "title": "",
  "body": " focus_population_data |> mutate(Births_per_capita = Births \/ Population, Deaths_per_capita = Deaths \/ Population) |> pivot_longer(cols = c(Births_per_capita, Deaths_per_capita), names_to = \"rate_name\", values_to = \"per_capita_rate\") |> ggplot(mapping = aes(x = Population, y = per_capita_rate, color = rate_name, shape = rate_name)) + geom_point()  "
},
{
  "id": "listing-US-per-capita-death-01",
  "level": "2",
  "url": "sec-mm-variable-relations.html#listing-US-per-capita-death-01",
  "type": "Listing",
  "number": "1.6.10",
  "title": "",
  "body": " work_data <- focus_population_data |> mutate(Births_per_capita = Births \/ Population, Deaths_per_capita = Deaths \/ Population) death_pc_model <- lm(formula = Deaths_per_capita ~ Population, data = work_data) death_pc_model$coefficients ggplot(data = work_data, mapping = aes(x = Population, y = Deaths_per_capita)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE)   (Intercept) Population 1.164158e-02 -1.123642e-11   "
},
{
  "id": "population-agent-based",
  "level": "1",
  "url": "population-agent-based.html",
  "type": "Section",
  "number": "2.1",
  "title": "An Agent Based Motivation for Dynamics",
  "body": " An Agent Based Motivation for Dynamics   We start our modeling by thinking about an agent-based model . An agent-based model is a computer simulation in which abstract agents are defined on a computer with a collection of rules for what they do in time and how the different agents interact with one another. In the context of a population, we might think of the agents as simulating individuals within a virtual population. The rules describe the patterns of life that the individuals follow.  By first thinking about how we would implement an agent-based model for a system, we are engaging the process of establishing an abstract representation of the fundamental assumptions identified in a hypothesis on how the system develops in time. Generally, we want to minimize the number of rules while still capturing the essence of our hypothesis. Allowing the computer simulation to follow our rules, we can observe the dynamics relatively quickly and make virtual measurements that might guide a more mathematical model.    NetLogo Overview   NetLogo (see https:\/\/ccl.northwestern.edu\/netlogo\/ ) is an example of an agent-based modeling environment, made freely available under the GNU General Public License . The agents are easily visualized as characters (called turtles) that move about a rectangular plot. The plot is subdivided into patches so that you can assign different rules of behavior that depend on which patch each turtle is on.  Rather than explain everything about NetLogo here, I refer you to the excellent documentation on the NetLogo website. There are three useful tutorials to get started: Tutorial 1 (Running Models), Tutorial 2 (On Turtles and Patches), and Tutorial 3 (Building a Model). In addition, the NetLogo Programming Guide explains the structure of how to program and the NetLogo Dictionary summarizes the commands that agents automatically inherit.  Demo code associated with this document was written to run in NetLogo 6.4. Links are provided to download the full model. Elements of the code will be discussed. Individuals in the population will be modeled as turtle agents (meaning they are movable).    Environmentally Naive Births and Deaths  When trying to define rules for how an individual will give birth to new individuals or die, we might consider complicating factors. For example, we might expect that births and death would depend on the health of the individual as well as the state of the environment in which the individual is living. However, the simplest models would not take these into account. The simplest rule for reproduction might be to decide randomly whether or not to give birth at a given cycle (tick) for the system. Similarly, we might have death be decided randomly.  We start with the NetLogo simulation available here: . The interface for the simulation is illustrated in . In the initial-population data field, you can set the number of individuals in the population at the start of the simulation. Then there are sliders that allow you to control the percent of individuals during each population cycle that will give birth or that will die. When you press the setup button, the population will reset based on your initial-population entry. When you press the go button, individuals will scramble around the screen randomly and give birth or die based on your settings. Press go a second time to stop the simulation.   Interface for naive-population.nlogo .    You can inspect the code describing the rules for the simulation by selecting the code tab at the top of the NetLogo window. Much of the code specifies rules for the agent and environment visualization, such as stating that our individuals are people , defining their shapes and colors, and giving rules for how to move randomly on the screen. This gives us something interesting to look at, but does not have much to do with the biologically relevant questions of how the population changes.  In the go code fragment, there are statements where we ask all people to do three things: try-reproduce (give birth or not), move , try-survive (die or not). The names include try- as a way to indicate there is some decision involved here. The code fragment in is a minimal approach for implementing random birth and death that is naive in regards to the environment. The expression random-float 100 creates a random number between 0 and 100, so saying if random-float 100 < birth-percent [...] calculates such a random number and compares it to the number in the birth-percent input field. If the random number is less than birth-percent , then the command inside the brackets ( hatch 1 ) is sent to the corresponding person under simulation (creating a new person). A similar calculation occurs for each person to see if they should die (remove the person).   to try-reproduce ;; global 'birth-percent' = percent of cycles ;; in which to reproduce if random-float 100 < birth-percent [ hatch 1 ] end to try-survive ;; and failure is to die ;; global 'death-percent' = percent of cycles ;; in which to die if random-float 100 < death-percent [ die ] end   The actual code is slightly more complex, in that it actually creates temporary agents that are markers for birth and death events. This allows the simulation to count how many events occur each cycle by checking the simulation for how many birth-markers or death-markers are in the system. You will also find code at the start of the go code that kills all of the markers before proceeding so that each cycle of the simulation only shows markers for the most recent set of events.  If we ran a simulation using these naive rules for reproduction and survival, with every agent randomly deciding whether it will reproduce and whether it will die, we would discover that there is a lot of randomness but that the number of births and deaths seem to be related to the population size. The following graph is typical of such a simulation.    Plot of total population, the number of births and deaths for a naive reproductive model with birth-percent = 16 and death-percent = 9 and initial-population = 20 .   This figure illustrates that larger populations result in more births and deaths. In fact, because of how the birth and death events were randomly determined based on a percentage of the number of tick cycles for each individual, we would expect that the number of births and deaths are approximately just the corresponding percentage of the total population size. Of course, because the simulation involves random decisions, there are fluctuations above and below that amount. This randomness is called demographic stochasticity .  We would like to look at the relationship between the number of births and deaths with respect to the population size. From the simulation, we can export the data for the simulation graph. If you right-click (or control-click) on the graph, you should see a menu that includes an option to copy the image or to export the results. When you select Export... , NetLogo will save the data points for the graph as a CSV file that can be imported into a spreadsheet or data analysis file. The file corresponding to our graph is available here: . If you open this with a spreadsheet application (e.g., Excel), you should see a view similar to .    Spreadsheet view of the exported data coresponding to   How is this sheet organized? NetLogo reports a variety of metadata at the top of the export file. For example, the second row contains the name of the NetLogo program and the third row contains the time when the data were created. Then we have a summary of the model parameters that were used for the given simulation, which we need to properly document the data or to perform analysis on the results. The last set of metadata for this file is a list of the pens (plots) that were included in the graph.  The actual data coming from the simulation starts in row 20. Each pen (plot) gets four reported values, where the first two values are the coordinates of the plotted point. Because this graph was plotting values against time, the -coordinates for each pen are all the same and correspond to the time as tracked by the number of completed cycles. The values of the state variables , , and correspond to the -coordinates of each plot, appearing in columns B , F , and J , which are ordinally (counting order) the 2nd, 6th, and 10th columns.  Before we proceed, we also need to understand that NetLogo is reporting values for the population , births , and deaths that were present at the end of each cycle. That is, there are actually two different population values associated with each time cycle. The population at the start of the cycle represents the number of individual people in the simulation. Then we go through the births and deaths resulting in a new population value at the end of the cycle . The values are related by the equation , in that the final number of individuals can be found by adding the number of births and then subtracting the number of deaths. The population column in the dataset corresponds to , and we are going to want to know , which we can find by solving the equation. This gives .  Once we import our data, we will generate a new column that contains the value of . Then we will examine the relation between the number of births and deaths and the starting population value. Specifically, we will create graph corresponding to and . The code to generate this result using tidyverse libraries is given below.   library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Import the data netlogo_data <- read_csv(\"naive-population-graph-export.csv\", skip = 19, col_names = FALSE) # Select only columns 1, 2, 6, 10 and assign names # Then add a new column for P_start netlogo_table <- netlogo_data |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) # Pivot columns B and D values into a single column Rate # Then plot Rate vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point()     Plot of birth and death rates for each time step of the simulation with respect to the population size at the beginning of that time step for the naive model.   The plot suggests that the number of births and deaths occurring during each time period is approximately proportional to the population size (i.e., linear graphs passing through ). Let's add best fit proportional lines and then see what the corresponding coefficients for the models mean.   # Find the model coefficients lm(formula = B ~ 0 + P_start, data = netlogo_table) lm(formula = D ~ 0 + P_start, data = netlogo_table) # Redraw the figure adding the best fit proportional lines netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ 0 + x, linewidth = 1, se = FALSE)   Call: lm(formula = B ~ 0 + P_start, data = netlogo_table) Coefficients: P_start 0.1575 ----- Call: lm(formula = D ~ 0 + P_start, data = netlogo_table) Coefficients: P_start 0.09003     When we look at the coefficients, notice that they are essentially the model parameters. The proportionality coefficient for the birth rate was estimated as 0.1575, which is remarkable close to decimal value for the model parameter birth-percent of 0.16. Similarly, the proportionality coefficient for the death rate was estimated as 0.09003 and is remarkably close to the decimal value of death-percent of 0.09.  Finally, we look at the per capita birth and death rates. Recall that per capita rates are calculated by dividing the regular rate by the population size. In our case, this means we divide it by the value P_start .   # Pivot columns B and D values into a single column Rate # Then calculate per capita rates # Then plot per_capita_rate vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> mutate(per_capita_rate = Rate \/ P_start) |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point()    Notice that the per capita graph has more randomness for small populations. This is typical behavior for demographic stochasticity , as the random variation in births and deaths is much larger relative to the population size when the population size itself is small. However, you should still be able to see that the per capita rates are roughly constant across the populations. Those constant values correspond precisely to the proportionality constants that we found earlier.  This should make sense. The proportional models we found earlier were saying that the number of births are a coefficient times , say where we estimated (and our simulation used the exact value ). But the per capita rate is defined by . Based on our proportional model, this must mean the per capita birth rate is .  In other words, a birth or death rate that is proportional to the population size means the same thing as saying that the corresponding per capita rate is constant.    Density-Dependent Births and Deaths  A more complex rule for population dynamics would include density-dependence. A population does not grow without bound. When the population is crowded, the birth and death rates for individuals change. Competition between individuals might result in fewer resources per individual. Crowded conditions might increase sickness or injuries. Such conditions generally lower the birth rates and increase the death rates for the population.  One simplistic approach to simulate these density-dependent effects in NetLogo would be to identify how many individuals are on a common patch and treat that as the local density. We might then directly increase the percentage of individuals that would die based on this density. This approach captures the idea of density dependence but does not attempt to attribute those changes to actual interactions. More advanced simulations would require directly modeling the environment itself.  One possible implementation for a NetLogo simulation is given here: . The interface is illustrated in . The simulation allows you to specify the initial population size, the birth rate as number of births per thousand individuals per cycle, and options to find the death rate that decreases as a population increases. The death rate calculates for each individual a value local-death-percent based on the how many individuals are sharing the patch where the individual is located. Let represent a specific patch, and let represent the number of individuals located on patch . Then local-death-percent , represented by a variable (per capita death) at the patch is calculated by where is the reference death-per-thousand converted to a decimal and is the death-increment .   Interface for density-dependent-population.nlogo .    To implement this strategy, each individual will need to keep track of its own local-death-percent , which is implemented in NetLogo by the following command.  people-own [ local-death-percent ]  We cause each patch to update all of the agents that belong to that patch with an action called density-update . The patch identifies all local individuals and then tells each person on the patch what their local death probability should be based on how many neighbors are competing for the same resources.  to density-update ;; this is a command for patches ;; create a temporary variable that counts all individuals on patch let density count turtles-here ;; use that density to compute a variable death percentage for ;; each individual living on the current patch ask turtles-here [ ;; death-percent is \"y-intercept\" ;; death-increment is \"slope\" set local-death-percent (death-percent + death-increment * density) ] end  Now, the rest of the simulation is essentially the same as before, except that the attempt-survive action has been modified to use local-death-percent .  to attempt-survive ;; and failure is to die ;; 'local-death-percent' = calculated by patches if random-float 100 < local-death-percent [ die ] end  The following graph comes from such a simulation using this type of density-dependence. The data for the graph has been exported as .    Plot of total population, the number of births and deaths for a density-dependent growth model with birth-percent = 16 and death-percent = 9 and death-increment = 0.3 .   Notice that the population does not grow indefinitely. As the population increases, the death rate increases faster than the birth rate so that the population growth rate ultimately decreases. The population levels out. We say that the population is approaching a carrying capacity , which is the population that the environment can sustain at a steady-state.  Let us look at how the birth and death rates relate to the population size, similar to what we did earlier with the naive birth\/death model. We will import the density-dependent data into R and plot the per capita birth and death rates against the population size at the start of the cycle.   library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Import the data netlogo_data <- read_csv(\"density-dependent-population-graph-export.csv\", skip = 19, col_names = FALSE) # Select only columns 1, 2, 6, 10 and assign names # Then add a new column for P_start netlogo_table <- netlogo_data |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) # Pivot columns B and D values into a single column Rate # Calculate per capita rates. # Then plot per capita rates vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> mutate(per_capita_rate = Rate \/ P_start) |> ggplot(mapping = aes(x = P_start, y = per_capita_rate, color = Rate_Type, shape = Rate_Type)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ x)    Notice that the per capita birth rate is essentially constant across the different population sizes. That is exactly how the simulation was set up to behave. Now notice how the per capita death rate is increasing as the population gets larger. There will be a point where the per capita death rate exactly matches the per capita birth rate. At that population size, the number of new births will exactly balance the number of deaths. This population will be the carrying capactiy. Notice that if the population is above the carrying capacity, the per capita death rate will exceed the birth rate causing the population to decline. We will explore this idea mathematically in the study of equilibrium values , of which a carrying capacity is an example.    Motivated by dynamics of a population simulated with births and deaths, we will next look at deterministic models for population growth. The agent-based simulations we have just been discussing included demographic stochasticity, the randomness related to random birth and death events. In our deterministic models that are about to be developed, the models will not include the stochasticity. They will represent the average behavior expected for a population. For large population sizes, demographic stochasticity is negligible, so we could also think of our deterministic models as describing behavior of large populations.   "
},
{
  "id": "population-agent-based-2-1",
  "level": "2",
  "url": "population-agent-based.html#population-agent-based-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "agent-based model "
},
{
  "id": "fig-naive-population-interface",
  "level": "2",
  "url": "population-agent-based.html#fig-naive-population-interface",
  "type": "Figure",
  "number": "2.1.1",
  "title": "",
  "body": " Interface for naive-population.nlogo .   "
},
{
  "id": "listing-naive-population-reproduce-survive",
  "level": "2",
  "url": "population-agent-based.html#listing-naive-population-reproduce-survive",
  "type": "Listing",
  "number": "2.1.2",
  "title": "",
  "body": " to try-reproduce ;; global 'birth-percent' = percent of cycles ;; in which to reproduce if random-float 100 < birth-percent [ hatch 1 ] end to try-survive ;; and failure is to die ;; global 'death-percent' = percent of cycles ;; in which to die if random-float 100 < death-percent [ die ] end  "
},
{
  "id": "fig-nl-pop-dyn-naive-dynamics",
  "level": "2",
  "url": "population-agent-based.html#fig-nl-pop-dyn-naive-dynamics",
  "type": "Figure",
  "number": "2.1.3",
  "title": "",
  "body": "  Plot of total population, the number of births and deaths for a naive reproductive model with birth-percent = 16 and death-percent = 9 and initial-population = 20 .  "
},
{
  "id": "population-agent-naive-11",
  "level": "2",
  "url": "population-agent-based.html#population-agent-naive-11",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "demographic stochasticity "
},
{
  "id": "fig-nl-pop-dyn-naive-csv",
  "level": "2",
  "url": "population-agent-based.html#fig-nl-pop-dyn-naive-csv",
  "type": "Figure",
  "number": "2.1.4",
  "title": "",
  "body": "  Spreadsheet view of the exported data coresponding to  "
},
{
  "id": "population-agent-naive-14",
  "level": "2",
  "url": "population-agent-based.html#population-agent-naive-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "metadata model parameters "
},
{
  "id": "population-agent-naive-15",
  "level": "2",
  "url": "population-agent-based.html#population-agent-naive-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "coordinates "
},
{
  "id": "listing-naive-population-rates",
  "level": "2",
  "url": "population-agent-based.html#listing-naive-population-rates",
  "type": "Listing",
  "number": "2.1.5",
  "title": "",
  "body": " library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Import the data netlogo_data <- read_csv(\"naive-population-graph-export.csv\", skip = 19, col_names = FALSE) # Select only columns 1, 2, 6, 10 and assign names # Then add a new column for P_start netlogo_table <- netlogo_data |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) # Pivot columns B and D values into a single column Rate # Then plot Rate vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point()  "
},
{
  "id": "population-agent-naive-19",
  "level": "2",
  "url": "population-agent-based.html#population-agent-naive-19",
  "type": "Figure",
  "number": "2.1.6",
  "title": "",
  "body": "  Plot of birth and death rates for each time step of the simulation with respect to the population size at the beginning of that time step for the naive model.  "
},
{
  "id": "listing-naive-population-rates-lm",
  "level": "2",
  "url": "population-agent-based.html#listing-naive-population-rates-lm",
  "type": "Listing",
  "number": "2.1.7",
  "title": "",
  "body": " # Find the model coefficients lm(formula = B ~ 0 + P_start, data = netlogo_table) lm(formula = D ~ 0 + P_start, data = netlogo_table) # Redraw the figure adding the best fit proportional lines netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ 0 + x, linewidth = 1, se = FALSE)   Call: lm(formula = B ~ 0 + P_start, data = netlogo_table) Coefficients: P_start 0.1575 ----- Call: lm(formula = D ~ 0 + P_start, data = netlogo_table) Coefficients: P_start 0.09003   "
},
{
  "id": "listing-naive-population-rates-per-capita",
  "level": "2",
  "url": "population-agent-based.html#listing-naive-population-rates-per-capita",
  "type": "Listing",
  "number": "2.1.8",
  "title": "",
  "body": " # Pivot columns B and D values into a single column Rate # Then calculate per capita rates # Then plot per_capita_rate vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> mutate(per_capita_rate = Rate \/ P_start) |> ggplot(mapping = aes(x = P_start, y = Rate, color = Rate_Type, shape = Rate_Type)) + geom_point()  "
},
{
  "id": "population-agent-naive-27",
  "level": "2",
  "url": "population-agent-based.html#population-agent-naive-27",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "demographic stochasticity "
},
{
  "id": "fig-density-dependent-population-interface",
  "level": "2",
  "url": "population-agent-based.html#fig-density-dependent-population-interface",
  "type": "Figure",
  "number": "2.1.9",
  "title": "",
  "body": " Interface for density-dependent-population.nlogo .   "
},
{
  "id": "population-agent-density-dependent-13",
  "level": "2",
  "url": "population-agent-based.html#population-agent-density-dependent-13",
  "type": "Figure",
  "number": "2.1.10",
  "title": "",
  "body": "  Plot of total population, the number of births and deaths for a density-dependent growth model with birth-percent = 16 and death-percent = 9 and death-increment = 0.3 .  "
},
{
  "id": "population-agent-density-dependent-14",
  "level": "2",
  "url": "population-agent-based.html#population-agent-density-dependent-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "carrying capacity "
},
{
  "id": "listing-density-dependent-population-rates",
  "level": "2",
  "url": "population-agent-based.html#listing-density-dependent-population-rates",
  "type": "Listing",
  "number": "2.1.11",
  "title": "",
  "body": " library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(tidyr) # To tidy data (pivot_longer) library(ggplot2) # To work with graphs (ggplot) # Import the data netlogo_data <- read_csv(\"density-dependent-population-graph-export.csv\", skip = 19, col_names = FALSE) # Select only columns 1, 2, 6, 10 and assign names # Then add a new column for P_start netlogo_table <- netlogo_data |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) # Pivot columns B and D values into a single column Rate # Calculate per capita rates. # Then plot per capita rates vs P_start to see relations netlogo_table |> pivot_longer(cols = c(B, D), names_to = \"Rate_Type\", values_to = \"Rate\") |> mutate(per_capita_rate = Rate \/ P_start) |> ggplot(mapping = aes(x = P_start, y = per_capita_rate, color = Rate_Type, shape = Rate_Type)) + geom_point() + geom_smooth(method = \"lm\", formula = y ~ x)  "
},
{
  "id": "population-agent-density-dependent-18",
  "level": "2",
  "url": "population-agent-based.html#population-agent-density-dependent-18",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "equilibrium values "
},
{
  "id": "sec-population-discrete",
  "level": "1",
  "url": "sec-population-discrete.html",
  "type": "Section",
  "number": "2.2",
  "title": "Discrete Population Models",
  "body": " Discrete Population Models  Many organisms reproduce only during specific seasons. For example, annual plants grow from seeds that germinate during the spring, flower in the summer fertilizing new seeds, and disperse the seeds in the autumn for the following year. Some insects have a very specific pattern of growth, passing through various stages of development to emerge for mating at a specific time of the year, with the Mayfly as a particular example. Salmon eggs are fertilized in river tributaries during a specific spawning season; the eggs hatch into salmon fry which, when they are old enough, migrate to the ocean as immature juveniles; and after several years of growing in the ocean, they return as fertile adults to the same tributary for another spawning season. For such organisms, we can think of the new offspring as annual recruits to the overall population, all of which are added in a single burst.  To model a population with clearly delineated reproductive events, we generally desire a model that describes the size of the population at the same point of the reproductive cycle. For example, we might want to look at the sequence of the density of a particular flowering plants each year at a particular study area. Or we might want to count the number of spawning salmon swimming up a particular tributary each year. Even for models that reproduce continuously or multiple times during a season, we might consider that we only observe those population as regular events.  A discrete-time model is a model of the state of a system that is measured at regular-spaced, distinct moments of time. In this section, we introduce the study of populations using discrete-time models. More specifically, we will introduce discrete models involving constant per capita rates. In the next section, we continue the study of discrete models where we look at density dependence.  The other type of model is a continuous-time model in which each state variable is modeled as a continuous function of time. Those models require the introduction of differential equations where the rates of change are characterized by equations involving the derivatives of the functions as one of the state variables. We will look at continuous-time models in a later chapter.  Mathematically, discrete-time models involve modeling using sequences . A sequence is an ordered set of numbers. Suppose that a system has a variable that is measured at regular intervals (e.g., a population). We often think of our variable as having an initial value and think of subsequent measurements as counting the number of additional observations. An index variable is a variable that represents the count (or index) through the observations. The value of the variable for a given index is indicated by writing the index value as a subscript on the variable, such as . We will commonly think of the first value of a sequence as corresponding to index , so that index values are interpreted as the number of intervals following that initial observation. Formally, a sequence is a function where the domain (index-values) consist only of integers.   Consider a population that is recorded at regular intervals with the following values: 199, 217, 236, 257, 264, 301, 312, 315, 331, …. If we let represent the population size, then the sequence has an initial value and subsequent values , , , and so on.   As motivated by our agent-based models, we might think of our population as changing through births and deaths. We might also include immigration and emigration. We can think of death and emigration as sources of loss, with individuals who were counted in the previous population and remain in the population for the next observation as survivors. Individuals that are new to the population, either from birth or from immigration, can be considered as recruits. The total population each year is described by the equation If we classified losses as deaths and emigrants and recruits as births and immigrants, we might consider the more detailed equation This is visualized as the graphical model shown in , shown again here.   A mathematical model for a population represents an abstraction of this pattern. First, we will consider each of the terms as variables in a system. Then we will seek mathematical equations that relate these variables in a way that will allow us to predict how the variables change. Because the real system involves stochasticity as well as more variables than we can reasonably include, our equations will only attempt to model enough of the behavior that we deem adequate and necessary to characterize the behavior we seek to describe.  We begin by defining our system. Let represent the population. Let represent the number of births, or more precisely, the number of individuals in that were born since the last observation and have survived for the current census. Let represent the number of deaths of individuals that were counted in the previous observation. Let and represent the number of emigrants (individuals of the previous census who left) and the number of immigrants (counted individuals that arrived since the previous census), respectively.  Each of these variables in the system represent sequences. That is, we will think of the variable counting time cycles, say , as the index. The population at time cycle is the sequence value . We will often want to talk about two consecutive values in the sequences. represents the population in the cycle , meaning it is the next population value after . Similarly, represents the population in the previous time cycle. Note that by our definition, represents the number of births after  was observed through the time that is observed.  We create a mathematical model by writing an equation about the sequence values. The new population value is found by taking the previous population value and adding the births and immigrations during the time cycle and subtracting the deaths and emigrations during that same cycle. This is expressed using the equation We often rewrite this equation as a difference equation that only shows the change in the sequence,   The model is not yet complete. We need model equations for each of the terms describing births, deaths, and migration. Our next step is to create equations relating the various terms. In particular, different models correspond to applying different equations that will allow us to find the birth, death and migration rates in terms of the previous population value.  The naive model for reproduction was that the number of births and deaths are proportional to the population. That is, in terms of our sequence, there are constants and such that We call the constants and the per capita birth rate and the per capita death rate , respectively. The phrase per capita literally means per head, and the per capita rates represent the average per individual contribution to birth and death. Rewriting the equations, we could instead define  and as the following ratios, which we are modeling as being constant. More advanced models consider these ratios as changing. We require that and .  A visual model for our constant per capita birth and death rates is shown in . The formulas for the individual rates are shown on the rate arrows. In addition, to emphasize the dependence of the birth rate on the population size, a dashed line is drawn from the population's box circling back to the birth rate. Rates leaving a population (like the death rate) are always assumed to have this dependence.   A visual model for per capita birth and death rates.    In the absence of migration, the constant per capita rate model leads to a dynamic model We can rewrite this as where is called the per capita net growth rate. The value of physically must satisfy , as corresponds to no new births ( ) and every individual dying ( ). This simplified model is often visualized as the graphical model shown in . The birth and death contributions are combined into the loop, which represents both losses (individuals leaving the population) and gains (individuals entering the population). This equation, called the recursive equation , is identical to the equation for compounded interest where represents that percent growth rate.   A visual model showing a constant per capita net growth rate.    Just as compound interest results in exponential growth, the constant per capita model results in a population that grows or decays exponentially. Most of our models will not have nice explicit formulas, but this model will. So we start by looking at the exact mathematics describing our dynamics.  The starting population is represented by . Our model gives us a relation between and : . But the same model gives us a relation between and : . If we substitute our value for into the second equation, we find . Repeating this cycle after cyle, we find the classic formula of a geometric sequence for the population size after cycles, This representation of the sequence is called the explicit formula and it allows us to compute the population value knowing only index and the initial value. This geometric sequence corresponds to exponential growth when and to exponential decay when . In the singular case where , the population remains constant.    A population with initial size 400 is tracked for one month, during which time there are 50 births and 40 deaths. If the population has constant monthly per capita rates, what will be the predicted population after one year?    Constant per capita rates mean that we can compute and from this observation and use them in our model: Consequently, our population model is given by the recursive formula with an initial value . The index variable is counting months of observation.  The explicit formula for this model is given by The population after a year corresponds to (12 months after starting), which has a value Under the assumptions of our model, namely constant per capita growth rates, we would predict a population of 538 individuals after one year.    How can we create this model in R? Because the model has an explicit formula for the population as a function of time, we first illustrate an explicit approach. For that approach, we generate a sequence to represent time and then calculate the corresponding population values. The time sequence is an array of values called a vector . In R (and other languages like Python and Matlab), it is possible to perform the same calculation on every entry in a vector with a single command. This is called a vectorized calculation . Basic arithmetic and mathematical functions are vectorized.   library(tidyr) library(ggplot2) # Set model parameters b <- 50\/400 d <- 40\/400 r <- b - d P0 <- 400 # Create a sequence of times t_vals <- seq(from = 0, to = 50) # Calculate the population using explicit model P_vals <- P0 * (1 + r)^t_vals # Plot the population data <- tibble(t = t_vals, P = P_vals) ggplot(data, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")   Below is a live Sage cell which can run self-contained R code. It can not support loading external files, so we can't use it with our CSV files. But it can do the simulation above if you copy the code into the cell and the press the Evaluate button. You also can try changing some of the parameters in the model to see how the dynamics change.   Sometimes (usually) an explicit formula is not going to be known. We can use the dynamic model equation itself to generate our sequence. The dynamic model gives us an equation to calculate a population at the end of a cycle based on the population at the beginning of the corresponding cycle. Because the equation relates a calculated value based on the previous value, we can only calculate one value at a time, instead of the vectorized all-at-once approach that was possible using the explicit formula. To repeat a calculation in a sequence of steps, we need to use a programming strategy called a loop . This approach is called an iterative calculation, because we iterate (or repeat) our calculation over and over again to find our results.  In R, the most common type of loop is the for -loop. This uses a basic coding pattern for (variable in vector) { command } . The vector will be replaced by an actual vector (array) of values that we want to iterate over, applying the command to each of them in turn. The variable is replaced by a variable name that will store the corresponding value from the vector, one at a time, so that we can refer to the value by a name in command . We can use multiple commands if they are put on separate lines (or separated by semicolons).  We will construct the same sequence of populations using an iterative approach. Our approach will compute two different sequences, one for the time of observation, and the other for the population value. And we will illustrate how we can do this in a tibble data-frame that was built to the size we wanted. R refers to positions in arrays starting at an index 1, but our starting time is typically starting at 0. The variable n in the code will refer to the index and not the time. To refer to the value in a vector at a given index, we use rectangular brackets with the index value inside, as in P_vals[12] would refer to the value in the vector P_vals at index position 12.   library(tidyr) library(ggplot2) # Set model parameters b <- 50\/400 d <- 40\/400 r <- b - d P0 <- 400 dt <- 1 # How much time between points # Set aside space for sequence values N_pts <- 51 # How many points we want, including initial t_vals <- double(N_pts) P_vals <- double(N_pts) # First cycle starting values t_vals[1] <- 0 P_vals[1] <- P0 # Iterate through the model for remaining values for (n in 2:N_pts) { # New time is previous time + dt t_vals[n] <- t_vals[n-1] + dt # New population using model P_vals[n] <- P_vals[n-1] * (1+r) } # Plot the population data2 <- tibble(t = t_vals, P = P_vals) ggplot(data2, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")    Because computer calculations always work with approximations to exact numbers, computer arithmetic introduces various rounding errors as calculations take place. Different methods of calculation create different rounding errors. Consequently, sequences calculated explicitly are unlikely to exactly match those calculated iteratively. However, these errors are generally small enough that we won't notice the difference.  "
},
{
  "id": "sec-population-discrete-4",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "discrete-time model "
},
{
  "id": "sec-population-discrete-5",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "continuous-time model differential equations "
},
{
  "id": "sec-population-discrete-6",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "sequences sequence index variable "
},
{
  "id": "sec-population-discrete-7",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-7",
  "type": "Example",
  "number": "2.2.1",
  "title": "",
  "body": " Consider a population that is recorded at regular intervals with the following values: 199, 217, 236, 257, 264, 301, 312, 315, 331, …. If we let represent the population size, then the sequence has an initial value and subsequent values , , , and so on.  "
},
{
  "id": "sec-population-discrete-10",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "mathematical model "
},
{
  "id": "sec-population-discrete-13",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "difference equation "
},
{
  "id": "sec-population-discrete-15",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-15",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "per capita birth rate per capita death rate "
},
{
  "id": "fig-population-visual-model-birth-death-rates",
  "level": "2",
  "url": "sec-population-discrete.html#fig-population-visual-model-birth-death-rates",
  "type": "Figure",
  "number": "2.2.2",
  "title": "",
  "body": " A visual model for per capita birth and death rates.   "
},
{
  "id": "sec-population-discrete-18",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-18",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "recursive equation "
},
{
  "id": "fig-population-visual-model-net-growth-rate",
  "level": "2",
  "url": "sec-population-discrete.html#fig-population-visual-model-net-growth-rate",
  "type": "Figure",
  "number": "2.2.3",
  "title": "",
  "body": " A visual model showing a constant per capita net growth rate.   "
},
{
  "id": "sec-population-discrete-21",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-21",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "geometric sequence explicit formula "
},
{
  "id": "sec-population-discrete-22",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-22",
  "type": "Example",
  "number": "2.2.4",
  "title": "",
  "body": "  A population with initial size 400 is tracked for one month, during which time there are 50 births and 40 deaths. If the population has constant monthly per capita rates, what will be the predicted population after one year?    Constant per capita rates mean that we can compute and from this observation and use them in our model: Consequently, our population model is given by the recursive formula with an initial value . The index variable is counting months of observation.  The explicit formula for this model is given by The population after a year corresponds to (12 months after starting), which has a value Under the assumptions of our model, namely constant per capita growth rates, we would predict a population of 538 individuals after one year.   "
},
{
  "id": "sec-population-discrete-23",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-23",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "vector vectorized calculation "
},
{
  "id": "sec-population-discrete-24",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-24",
  "type": "Listing",
  "number": "2.2.5",
  "title": "",
  "body": " library(tidyr) library(ggplot2) # Set model parameters b <- 50\/400 d <- 40\/400 r <- b - d P0 <- 400 # Create a sequence of times t_vals <- seq(from = 0, to = 50) # Calculate the population using explicit model P_vals <- P0 * (1 + r)^t_vals # Plot the population data <- tibble(t = t_vals, P = P_vals) ggplot(data, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")  "
},
{
  "id": "sec-population-discrete-27",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-27",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "loop iterative "
},
{
  "id": "sec-population-discrete-30",
  "level": "2",
  "url": "sec-population-discrete.html#sec-population-discrete-30",
  "type": "Listing",
  "number": "2.2.6",
  "title": "",
  "body": " library(tidyr) library(ggplot2) # Set model parameters b <- 50\/400 d <- 40\/400 r <- b - d P0 <- 400 dt <- 1 # How much time between points # Set aside space for sequence values N_pts <- 51 # How many points we want, including initial t_vals <- double(N_pts) P_vals <- double(N_pts) # First cycle starting values t_vals[1] <- 0 P_vals[1] <- P0 # Iterate through the model for remaining values for (n in 2:N_pts) { # New time is previous time + dt t_vals[n] <- t_vals[n-1] + dt # New population using model P_vals[n] <- P_vals[n-1] * (1+r) } # Plot the population data2 <- tibble(t = t_vals, P = P_vals) ggplot(data2, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")  "
},
{
  "id": "sec-population-density-dependent",
  "level": "1",
  "url": "sec-population-density-dependent.html",
  "type": "Section",
  "number": "2.3",
  "title": "Density Dependent Population Growth Models",
  "body": " Density Dependent Population Growth Models  A population with constant per capita growth rates sees exponential growth when the birth rate exceeds the death rate , and exponential decay when the ordering is reversed. However, real population can not really grow exponentially as there iare limited resources in the environment. Thus, for populations that experience environmental constraints, constant per capita growth rates are not appropriate.  We previously defined the per capita net growth rate where is the per capita birth rate and is the per capita death rate. Sometimes it is inconvenient or impossible to determine the birth and death rates separately. If we can at least measure the net change in the population, which will be equal to , then the per capita net growth rate will be a sequence defined by Density dependence means that the relation is not constant, but that depends on .  We turn our attention to the case that the per capita net growth rate can be modeled as a function of the population size , where a scatter plot of the points could be reasonably approximated by a function. We generally expect that the graph will be a decreasing function because as the population gets larger, the growth rate should decrease. For a very large population, we expect since the population would be greater than its carrying capacity. Physically, however, we will always have , with corresponding to complete extinction.  If we revisited the density-dependent agent-based model in Section , we can plot the per capita net growth rate computed at each time step with respect to the size of the population at the beginning of the step. We will actually start with the per capita birth and death rates, and .   library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(ggplot2) # To work with graphs (ggplot) # Import the data # Then select only columns 1, 2, 6, 10 # Then add a column for P_start # Then add more columns for per capita # Then save the result as our data read_csv(\"density-dependent-population-graph-export.csv\", skip = 19, col_names = FALSE) |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) |> mutate(b = B\/P_start, d = D\/P_start) -> density_data # Create a graph for per capita births ggplot(data = density_data mapping = aes(x = P_start, y = b) + geom_point(color = \"blue\") + geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\") + labs(x = \"Population\", y = \"per capita births\") # Create a graph for per capita deaths ggplot(data = density_data mapping = aes(x = P_start, y = d) + geom_point(color = \"red\") + geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\") + labs(x = \"Population\", y = \"per capita deaths\")     Based on our result, it would appear that the per capita birth rate is constant with respect to the population size. But the per capita death rate is an increasing linear function of the population size. This should make sense based on how the simulation was generated, because that is exactly what happened. We can use R to estimate the parameters of the constant per capita birth rate and the coefficients of the line for the per capita death rate.   # per capita birth has no dependence on P_start, just y-intercept b_model <- lm(formula = b ~ 1, data = density_data) b_model$coefficients    (Intercept) 0.04787737    # per capita death has linear dependence on P_start d_model <- lm(formula = d ~ P_start, data = density_data) d_model$coefficients    (Intercept) P_start 3.249201e-02 3.796575e-06   The overall per capita growth rate can then be found, , as the difference of the per capita birth rate minus the per capita death rate. In order to develop an actual model, we need to find a formula that captures the relation. The per capita birth rate in our example was constant, which we can just represent by the parameter . The per capita death rate was an increasing linear function of population, so we need two parameters for the intercept and slope of that function, . The value is the per capita death rate when there are no individuals around. The value represents the additional probability of death per individual added to the population. With these formulas, we can no calculate the per capita growth rate, . If we defined as the per capita growth rate in the absence of individuals, then we see that is a decreasing linear function of , . Specifically for our simulation, our estimates for the parameters are and , so that and .  Once we have our model formula for , we can use it to create a model for the population itself. The new population will be found by taking the old population and adding the net change in population . This gives us the basic model equation . We now use the model formula for , which itself depends on (in place of ), to give . Distributing out the on the right, we arrive at a model equation, , where and are the model parameters.  This model is a classic model in mathematical biology called the discrete logistic model , and it is an example of a nonlinear dynamic model . It is called nonlinear because the formula for is not just a linear function of due to the presence of the squared term . Nonlinear models generally do not have known explicity solutions. But we can implement numerical approximations through iteration.   library(tidyr) library(ggplot2) # Set model parameters b <- 0.04788 d0 <- 0.03249 r0 <- b - d0 a <- 3.797e-6 # Initial value P0 = 20 dt = 1 # Set aside space for sequence values N_pts <- 501 # How many points we want, including initial t_vals <- double(N_pts) P_vals <- double(N_pts) # First cycle starting values t_vals[1] <- 0 P_vals[1] <- P0 # Iterate through the model for remaining values for (n in 2:N_pts) { # New time is previous time + dt t_vals[n] <- t_vals[n-1] + dt # New population using model P_vals[n] <- P_vals[n-1] * (1 + r0 - a * P_vals[n-1]) } # Plot the population data2 <- tibble(t = t_vals, P = P_vals) ggplot(data2, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")    Resulting plot for the discrete logistic model simulation with stated parameter values and initial value .    Below is a live Sage cell which can run self-contained R code. It can not support loading external files, so we can't use it with our CSV files. But it can do the simulation above if you copy the code into the cell and the press the Evaluate button. You also can try changing some of the parameters in the model to see how the dynamics change.   We are likely curious about how well the model matches the data that motivated it. Assuming that you have both the imported data from NetLogo and the simulation calculated above in the same R session, we can combine the graphs of the two datasets into a single figure. The results shown in show a clear resemblance between the NetLogo simulation data with the modeled sequence. The demographic stochasticity of the NetLogo simulation as well as the estimated nature of our model parameters explain the discrepancies between the two models.    # Two datasets, so the global source of data is NULL ggplot(data=NULL, mapping=aes(x = \"time\", y = \"P\")) + # Each geometric layer specifies its own data set. geom_point(data=netlogo_data, mapping = aes(x=X1, y=X2), color=\"blue\") + geom_point(data=data2, mapping = aes(x=t, y=P), color=\"black\", size=0.5) + labs(x = \"time\", y = \"P\")     Resulting plot for the discrete logistic model simulation with stated parameter values and initial value .    "
},
{
  "id": "listing-nl-density-dependent-per-capita-rates",
  "level": "2",
  "url": "sec-population-density-dependent.html#listing-nl-density-dependent-per-capita-rates",
  "type": "Listing",
  "number": "2.3.1",
  "title": "",
  "body": " library(readr) # To load CSV files (read_csv) library(dplyr) # To reorganize (select) library(ggplot2) # To work with graphs (ggplot) # Import the data # Then select only columns 1, 2, 6, 10 # Then add a column for P_start # Then add more columns for per capita # Then save the result as our data read_csv(\"density-dependent-population-graph-export.csv\", skip = 19, col_names = FALSE) |> select(tick = 1, P_end = 2, B = 6, D = 10) |> mutate(P_start = P_end - B + D) |> mutate(b = B\/P_start, d = D\/P_start) -> density_data # Create a graph for per capita births ggplot(data = density_data mapping = aes(x = P_start, y = b) + geom_point(color = \"blue\") + geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\") + labs(x = \"Population\", y = \"per capita births\") # Create a graph for per capita deaths ggplot(data = density_data mapping = aes(x = P_start, y = d) + geom_point(color = \"red\") + geom_smooth(method = \"lm\", formula = y ~ x, color = \"black\") + labs(x = \"Population\", y = \"per capita deaths\")  "
},
{
  "id": "sec-population-density-dependent-10",
  "level": "2",
  "url": "sec-population-density-dependent.html#sec-population-density-dependent-10",
  "type": "Listing",
  "number": "2.3.2",
  "title": "",
  "body": " # per capita birth has no dependence on P_start, just y-intercept b_model <- lm(formula = b ~ 1, data = density_data) b_model$coefficients  "
},
{
  "id": "sec-population-density-dependent-12",
  "level": "2",
  "url": "sec-population-density-dependent.html#sec-population-density-dependent-12",
  "type": "Listing",
  "number": "2.3.3",
  "title": "",
  "body": " # per capita death has linear dependence on P_start d_model <- lm(formula = d ~ P_start, data = density_data) d_model$coefficients  "
},
{
  "id": "sec-population-density-dependent-16",
  "level": "2",
  "url": "sec-population-density-dependent.html#sec-population-density-dependent-16",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "discrete logistic model nonlinear dynamic model "
},
{
  "id": "sec-population-density-dependent-17",
  "level": "2",
  "url": "sec-population-density-dependent.html#sec-population-density-dependent-17",
  "type": "Listing",
  "number": "2.3.4",
  "title": "",
  "body": " library(tidyr) library(ggplot2) # Set model parameters b <- 0.04788 d0 <- 0.03249 r0 <- b - d0 a <- 3.797e-6 # Initial value P0 = 20 dt = 1 # Set aside space for sequence values N_pts <- 501 # How many points we want, including initial t_vals <- double(N_pts) P_vals <- double(N_pts) # First cycle starting values t_vals[1] <- 0 P_vals[1] <- P0 # Iterate through the model for remaining values for (n in 2:N_pts) { # New time is previous time + dt t_vals[n] <- t_vals[n-1] + dt # New population using model P_vals[n] <- P_vals[n-1] * (1 + r0 - a * P_vals[n-1]) } # Plot the population data2 <- tibble(t = t_vals, P = P_vals) ggplot(data2, mapping = aes(x = t, y = P)) + geom_point(color = \"blue\") + labs(x = \"time [months]\", y = \"Population\")  "
},
{
  "id": "fig-discrete-logistic-simulation-01",
  "level": "2",
  "url": "sec-population-density-dependent.html#fig-discrete-logistic-simulation-01",
  "type": "Figure",
  "number": "2.3.5",
  "title": "",
  "body": " Resulting plot for the discrete logistic model simulation with stated parameter values and initial value .   "
},
{
  "id": "sec-population-density-dependent-22",
  "level": "2",
  "url": "sec-population-density-dependent.html#sec-population-density-dependent-22",
  "type": "Listing",
  "number": "2.3.6",
  "title": "",
  "body": "  # Two datasets, so the global source of data is NULL ggplot(data=NULL, mapping=aes(x = \"time\", y = \"P\")) + # Each geometric layer specifies its own data set. geom_point(data=netlogo_data, mapping = aes(x=X1, y=X2), color=\"blue\") + geom_point(data=data2, mapping = aes(x=t, y=P), color=\"black\", size=0.5) + labs(x = \"time\", y = \"P\")   "
},
{
  "id": "fig-discrete-logistic-with-nl-data",
  "level": "2",
  "url": "sec-population-density-dependent.html#fig-discrete-logistic-with-nl-data",
  "type": "Figure",
  "number": "2.3.7",
  "title": "",
  "body": " Resulting plot for the discrete logistic model simulation with stated parameter values and initial value .   "
},
{
  "id": "population-projection",
  "level": "1",
  "url": "population-projection.html",
  "type": "Section",
  "number": "2.4",
  "title": "Recursive Models Using Projection",
  "body": " Recursive Models Using Projection   In the previous section, we considered a recursive formula for the new population in terms of the per capita net growth rate, , where the new population is computed by the difference equation which is equivalent to the recursive formula The basic idea to the difference equation is that is the formula for the increment of change in the population, which is why that formula is added to the previous population.  In this section, we introduce an alternative way of thinking about computing the new population. In the above model, we effectively were thinking about the change in the population as a function of the previous population (specifically by thinking of the per capita rate as a function). We turn our attention now to thinking of the new population as itself being a function of the previous population. This function is called the projection function .    Projection Functions  A sequence is defined recursively if you have a formula to compute in terms of the value for . Generally, we have an equation that is solved for the new value in the form of . That is, the equation has been rewritten so that the new value is isolated on one side of the equation and is equal to some formula involving the previous value of the sequence. We then think of the formula involving as a function of . That function is named the projection function for the sequence because it allows us to project (i.e., forecast) the next value of the sequence knowing the current value in the sequence.   The difference equation with an initial value defines a sequence recursively. This is the model for constant per capita growth rates. If we solve this equation for , , we think of the right hand side as the projection function, . In terms of a simple variable (change to ), the projection function is defined by .  We saw earlier that this sequence results in geometric sequences that grow or decay exponentially. If we generate this sequence and look at the relation , all of those points are on the graph of the projection function . The following code generates the sequence recursively and demonstrates this relation.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value r <- 0.25 P0 <- 10 # Specify the size of the sequence and create space in memory num_pts <- 50 P <- double(num_pts) # Generate the sequence P[1] <- P0 for (n in 2:num_pts) { P[n] <- (1+r) * P[n-1] } # Store as P_start and P_end seq_data <- tibble(P_start = P[1:(num_pts-1)], P_end=P[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=0, to=max(P), length=500) # Vectorized calculation of y = f(x) y_vals <- (1+r)*x_vals # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = P_start, y = P_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))      The difference equation is the difference equation perspective for the discrete logistic model. Solving this equation for gives . The projection function must therefore be . More simply written, the projection function for the discrete logistic model is .  Again, if we generate a sequence to follow this model, each point in the relation will be on the graph of the projection function .   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value r0 <- 0.4 a <- 0.001 P0 <- 10 # Specify the size of the sequence and create space in memory num_pts <- 50 P <- double(num_pts) # Generate the sequence P[1] <- P0 for (n in 1:(num_pts-1)) { P[n+1] <- (1+r0) * P[n] - a * P[n]^2 } # Store as P_start and P_end seq_data <- tibble(P_start = P[1:(num_pts-1)], P_end=P[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=0, to=max(P), length=500) # Vectorized calculation of y = f(x) y_vals <- (1+r0) * x_vals - a * x_vals^2 # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = P_start, y = P_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))      Not all recursive sequences have biological motivations. In Calculus, Newton's method is frequently taught as a way to find the positive square root of any positive number . The square root is the positive solution to . Newton's method involves creating a sequence using the recursive equation . Solving this equation for , we find the equation that writes as a function of , . The projection function in this example is   The sequence generated in the code below solves for by using . The initial value was chosen as . The relation is graphed along with . The method converges very quickly, so not many distinct points appear.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value a <- 3 x0 <- 1 # Specify the size of the sequence and create space in memory num_pts <- 20 newton <- double(num_pts) # Generate the sequence newton[1] <- x0 for (n in 1:(num_pts-1)) { newton[n+1] <- newton[n]\/2 + a\/(2 * newton[n]) } # Store as x_start and x_end seq_data <- tibble(x_start = newton[1:(num_pts-1)], x_end=newton[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=min(newton), to=max(newton), length=200) # Vectorized calculation of y = f(x) y_vals <- x_vals \/ 2 + a \/ (2 * x_vals) # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = x_start, y = x_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))     In each of our examples above, we started with sequences defined recursively and showed that the relation always matched the graph for the projection function .` The projection function is the rule that when given the value of , we can predict the value of . From a modeling perspective, we find projection functions by looking at the relation given by the scatter plot of when data are available and find an appropriate function. When data are not available, we can construct hypotheses for the relation and build an appropriate model to explore the behavior if such a model were relevant.    The table below gives the values of a sequence for . Analyze the data to find a reasonable projection function.                                  We start by creating a plot of the projection relation, corresponding to a scatter plot of points . When , we have . The next few points are expressed below: We can create this graph in R using the following script. Our original set of data had index values , which corresponds to 11 points. However, when we think of our data as values before\/after, there can be at most 10 pairs. The code below defines columns that use a subset of the entries.   library(tidyr) library(ggplot2) # Create the sequence vector directly z <- c(1.00, 3.42, 10.21, 17.99, 6.50, 15.80, 11.95, 17.32, 8.37, 17.52, 7.82) N <- length(z) # z_start has all but the last value; z_end has all but the first value z_data <- tibble(z_start = z[1:N-1], z_end = z[2:N]) # Graph the relation ggplot(data = z_data, mapping = aes(x = z_start, y = z_end)) + geom_point(color=\"blue\")       The figure strongly suggests the shape of a parabola so that the relation likely involves a quadratic formula. A quadratic function has the form , which we could rewrite in the form . This can be interpreted as a linear model with a -intercept and two explanatory variables coming from and . We can continue our script to estimate the coefficients for the model by using lm with formula = y ~ x + x2 where x2 is going to be an extra column defined by x2 = x^2 . Add the following code to the script defined above or after having already executed the code above.   # Add new columns to z_data library(dplyr) z_data |> mutate(z = z_start) |> # z is a simpler name than z_start mutate(z2 = z^2) -> z_data2 # Do linear model z_model <- lm(formula = z_end ~ z + z2, data = z_data2) z_model$coefficients    (Intercept) z z2 0.0005194086 3.6003271165 -0.1800141078    From the regression, we see that we have values , , and . Based on those values, we could construct a sequence using the recursive equation . Our original sequence data only showed two decimal places in the values, so we should think of our coefficients as having their own uncertainty. Let's compare what happens with the sequence using those estimated values with another sequence using the very similar . The code below also illustrates how we can format a table.   # Model parameters a <- -0.180014 a2 <- -0.18 b <- 3.600327 b2 <- 3.6 c <- 0.0005194 # Initial value z0 <- 1.00 num_pts <- 10 # Build the sequences z and u z <- double(num_pts + 1) u <- double(num_pts + 1) z[1] <- z0 u[1] <- z0 for (n in 1:num_pts) { z[n+1] <- c + b * z[n] + a * z[n]^2 u[n+1] <- b2 * u[n] + a2 * u[n]^2 } # Layout a table showing the values my_data <- tibble(t = 0:num_pts, z = z, u = u) print(my_data)    # A tibble: 11 × 3 t z u <int> <dbl> <dbl> 1 0 1 1 2 1 3.42 3.42 3 2 10.2 10.2 4 3 18.0 18.0 5 4 6.50 6.50 6 5 15.8 15.8 7 6 12.0 11.9 8 7 17.3 17.3 9 8 8.38 8.37 10 9 17.5 17.5 11 10 7.80 7.82    Perhaps surprisingly, the rounded model did better than the fitted values. Why would this happen? The actual values of the original sequence, which I generated with a computer using the simplified parameters, were rounded in order to present them with two decimal places. Thus our starting sequence had built-in errors. When we calculated our parameters using the linear model, we did in fact find the model that matched our results with the least squared errors for the rounded sequence. However, the fitted equation did not reproduce the sequence because it actually models a nearby sequence. If we had worked with more decimal values in the original sequence, we would have found a closer model.  To close the topic, the two projection functions will be visually indistinguishable in a figure. So the code below generates the graph of the original sequence as points coupled with a smooth graph showing the projection function.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Original sequence z <- c(1.00, 3.42, 10.21, 17.99, 6.50, 15.80, 11.95, 17.32, 8.37, 17.52, 7.82) # Create the before\/after pairings z_proj_data <- tibble(z_start = z[1:10], z_end = z[2:11]) # Data for the projection function x <- seq(from = 0, to = 20, length=200) y <- 3.6 * x - 0.18 * x^2 # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = z_start, y = z_end, color = \"sequence\")) + geom_point(data = z_proj_data, size=3) + geom_path(mapping = aes(x = x, y = y, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))           Fixed Points and Equilibria  An equilibrium represents a state of balance. For example, in chemistry, an equilibrium in a chemical reaction means that there is a balance between the reaction rates that create a chemical and those that use the chemical. It is not that nothing is happening, but that the creation and loss are perfectly balanced.  A population can also be in equilibrium if the sources of all growth in the population is exactly balanced by the sources of all loss. That is, the rate of birth and immigration in a population would need to be exactly balanced by the rate of death and emigration. The effect of this balance is that the sequence is constant, namely that .  When a population is modeled by a projection function, , we can test whether an equilibrium is possible by seeing whether the equation has any solutions. That is, since is true for an equilibrium, we are looking for all values of that might be used for the sequence . We call solutions to the equation the fixed points of the function .    Recall that Newton's method for finding the square root introduced the projection function . Find all of the fixed points for this function.    We are solving the fixed point equation which becomes . Solving this equation by hand corresponds to the following steps. So the fixed points are the positive and negative square roots of .      A population has a per capita net growth rate that linearly decreases with the population, . Find the projection function and identify possible equilibria for this population.    The per capita net growth rate is related to the change in the population through births and deaths: . As a difference equation, the population can be modeled as . Using the given formula for , we can rewrite our model in recursive form as A projection function corresponds to the function in the equation , which we can recognize in this problem involves .  The fixed point equation allows us to find all fixed points (and therefore possible equilibria of the population). We solve the equation by factoring: By factoring an equation equal to zero, we find either (a fixed point) or (a simpler equation to find another fixed point). The other fixed point is . So the possible equilibria for this population model are the values or . (Notice how we interpreted in the context of the state variable rather than the fixed point variable .)    A sequence that starts at a fixed point will lead to a constant sequence, holding steady at the same value indefinitely. If the initial value of the sequence is not a fixed point, then next value will definitely be different and it can be challenging to predict in advance whether the sequence will eventually converge or not. Whether a sequence converges to a fixed point depends significantly on whether the fixed point is stable or unstable.  A fixed point is locally stable if every sequence that starts sufficiently close to the fixed point will always converge to the fixed point. Often, the sequence does not need to start very close at all to converge to a stable fixed point. However, a fixed point is locally unstable if regardless of how close you look, there will be at least one nearby initial value that results in a sequence that moves further away from the fixed point instead. That sequence might eventually return to this or another fixed point, but we only care if it initially moves away. For now, we will just look at the values of nearby sequences and see if they converge or not.    Find the fixed points for the projection function . Use numerical evidence to determine if each fixed point is locally stable or unstable.    We start by looking for fixed points algebraically. A fixed point is a solution to the equation . Using the formula of the projection function, the relevant equation is . Even though is a common factor, avoid the temptation to divide it out. This is a sure-fire way to lose an important solution. Instead, it is better to adopt a strategy solving using factoring. From this factored equation, we see solutions occur when or when . That is, is one fixed point. Solving results in a second fixed point .  To see if a fixed point is locally stable or unstable, we can get some numerical intuition by looking at sequence solutions that start relatively close to the fixed point. The first constructed sequence will look at the fixed point .   N <- 20 # Number of values we calculate # One sequence will have the fixed point as initial value fp_seq <- double(N+1) # Another sequence will be close nearby_seq <- double(N+1) # Define a projection function as a function project_fcn <- function(x) { 1.3*x - 0.05*x^2 } # Do two sequences at the same time fp_seq[1] <- 0 # At the fixed point nearby_seq[1] <- 0.1 # Just above the fixed point for (n in 1:N) { fp_seq[n+1] <- project_fcn( fp_seq[n] ) nearby_seq[n+1] <- project_fcn( nearby_seq[n] ) } # Organize into a tibble dataframe so both can be plotted together library(tidyr) library(dplyr) library(ggplot2) seq_data <- tibble(t = 0:N, fp = fp_seq, nearby = nearby_seq) # Combine fp and nearby into same common to be tidy style, then plot pivot_longer(seq_data, cols = c(fp, nearby), values_to = \"value\", names_to = \"sequence\") |> ggplot(mapping = aes(x = t, y = value, color = sequence)) + geom_point()     From the result, we see that the sequence that started just off the fixed point had sequence values the moved away from the fixed point sequence. This is strong evidence that the fixed point is locally unstable. It is not definitive because this one example doesn't show whether an even closer starting value might instead move toward the fixed point.  We next consider the fixed point at . Again, we visualize the fixed point sequence along with a sequence that starts nearby.   N <- 20 # Number of values we calculate # One sequence will have the fixed point as initial value fp_seq <- double(N+1) # Another sequence will be close nearby_seq <- double(N+1) # Define a projection function as a function project_fcn <- function(x) { 1.3*x - 0.05*x^2 } # Do two sequences at the same time fp_seq[1] <- 6 # At the fixed point nearby_seq[1] <- 6.1 # Just above the fixed point for (n in 1:N) { fp_seq[n+1] <- project_fcn( fp_seq[n] ) nearby_seq[n+1] <- project_fcn( nearby_seq[n] ) } # Organize into a tibble dataframe so both can be plotted together library(tidyr) library(dplyr) library(ggplot2) seq_data <- tibble(t = 0:N, fp = fp_seq, nearby = nearby_seq) # Combine fp and nearby into same common to be tidy style, then plot pivot_longer(seq_data, cols = c(fp, nearby), values_to = \"value\", names_to = \"sequence\") |> ggplot(mapping = aes(x = t, y = value, color = sequence)) + geom_point()     In this case, we see that the sequence that started just off the fixed point had sequence values the moved toward the fixed point sequence. This is strong evidence that the fixed point might be locally stable. It is not definitive all sequences that start sufficiently close need to demonstrate this behavior. We are only able to inspect a few at a time through graphs.    We will want a more definitive approach to determining whether fixed points are locally stable or unstable. The next section will demonstrate how the derivative of the projection function contains the necessary information to make this decision.   "
},
{
  "id": "population-projection-2-2",
  "level": "2",
  "url": "population-projection.html#population-projection-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "projection function "
},
{
  "id": "projection-functions-2",
  "level": "2",
  "url": "population-projection.html#projection-functions-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "recursively projection function "
},
{
  "id": "projection-functions-3",
  "level": "2",
  "url": "population-projection.html#projection-functions-3",
  "type": "Example",
  "number": "2.4.1",
  "title": "",
  "body": " The difference equation with an initial value defines a sequence recursively. This is the model for constant per capita growth rates. If we solve this equation for , , we think of the right hand side as the projection function, . In terms of a simple variable (change to ), the projection function is defined by .  We saw earlier that this sequence results in geometric sequences that grow or decay exponentially. If we generate this sequence and look at the relation , all of those points are on the graph of the projection function . The following code generates the sequence recursively and demonstrates this relation.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value r <- 0.25 P0 <- 10 # Specify the size of the sequence and create space in memory num_pts <- 50 P <- double(num_pts) # Generate the sequence P[1] <- P0 for (n in 2:num_pts) { P[n] <- (1+r) * P[n-1] } # Store as P_start and P_end seq_data <- tibble(P_start = P[1:(num_pts-1)], P_end=P[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=0, to=max(P), length=500) # Vectorized calculation of y = f(x) y_vals <- (1+r)*x_vals # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = P_start, y = P_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))    "
},
{
  "id": "projection-functions-4",
  "level": "2",
  "url": "population-projection.html#projection-functions-4",
  "type": "Example",
  "number": "2.4.3",
  "title": "",
  "body": " The difference equation is the difference equation perspective for the discrete logistic model. Solving this equation for gives . The projection function must therefore be . More simply written, the projection function for the discrete logistic model is .  Again, if we generate a sequence to follow this model, each point in the relation will be on the graph of the projection function .   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value r0 <- 0.4 a <- 0.001 P0 <- 10 # Specify the size of the sequence and create space in memory num_pts <- 50 P <- double(num_pts) # Generate the sequence P[1] <- P0 for (n in 1:(num_pts-1)) { P[n+1] <- (1+r0) * P[n] - a * P[n]^2 } # Store as P_start and P_end seq_data <- tibble(P_start = P[1:(num_pts-1)], P_end=P[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=0, to=max(P), length=500) # Vectorized calculation of y = f(x) y_vals <- (1+r0) * x_vals - a * x_vals^2 # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = P_start, y = P_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))    "
},
{
  "id": "projection-functions-5",
  "level": "2",
  "url": "population-projection.html#projection-functions-5",
  "type": "Example",
  "number": "2.4.5",
  "title": "",
  "body": " Not all recursive sequences have biological motivations. In Calculus, Newton's method is frequently taught as a way to find the positive square root of any positive number . The square root is the positive solution to . Newton's method involves creating a sequence using the recursive equation . Solving this equation for , we find the equation that writes as a function of , . The projection function in this example is   The sequence generated in the code below solves for by using . The initial value was chosen as . The relation is graphed along with . The method converges very quickly, so not many distinct points appear.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Set values for the model parameters and initial value a <- 3 x0 <- 1 # Specify the size of the sequence and create space in memory num_pts <- 20 newton <- double(num_pts) # Generate the sequence newton[1] <- x0 for (n in 1:(num_pts-1)) { newton[n+1] <- newton[n]\/2 + a\/(2 * newton[n]) } # Store as x_start and x_end seq_data <- tibble(x_start = newton[1:(num_pts-1)], x_end=newton[2:num_pts]) # Generate a graph of the projection function # Create x-values between 0 and the largest value of P in our data x_vals <- seq(from=min(newton), to=max(newton), length=200) # Vectorized calculation of y = f(x) y_vals <- x_vals \/ 2 + a \/ (2 * x_vals) # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = x_start, y = x_end, color = \"sequence\")) + geom_point(data = seq_data, size=3) + geom_path(mapping = aes(x = x_vals, y = y_vals, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))    "
},
{
  "id": "projection-functions-7",
  "level": "2",
  "url": "population-projection.html#projection-functions-7",
  "type": "Example",
  "number": "2.4.7",
  "title": "",
  "body": "  The table below gives the values of a sequence for . Analyze the data to find a reasonable projection function.                                  We start by creating a plot of the projection relation, corresponding to a scatter plot of points . When , we have . The next few points are expressed below: We can create this graph in R using the following script. Our original set of data had index values , which corresponds to 11 points. However, when we think of our data as values before\/after, there can be at most 10 pairs. The code below defines columns that use a subset of the entries.   library(tidyr) library(ggplot2) # Create the sequence vector directly z <- c(1.00, 3.42, 10.21, 17.99, 6.50, 15.80, 11.95, 17.32, 8.37, 17.52, 7.82) N <- length(z) # z_start has all but the last value; z_end has all but the first value z_data <- tibble(z_start = z[1:N-1], z_end = z[2:N]) # Graph the relation ggplot(data = z_data, mapping = aes(x = z_start, y = z_end)) + geom_point(color=\"blue\")       The figure strongly suggests the shape of a parabola so that the relation likely involves a quadratic formula. A quadratic function has the form , which we could rewrite in the form . This can be interpreted as a linear model with a -intercept and two explanatory variables coming from and . We can continue our script to estimate the coefficients for the model by using lm with formula = y ~ x + x2 where x2 is going to be an extra column defined by x2 = x^2 . Add the following code to the script defined above or after having already executed the code above.   # Add new columns to z_data library(dplyr) z_data |> mutate(z = z_start) |> # z is a simpler name than z_start mutate(z2 = z^2) -> z_data2 # Do linear model z_model <- lm(formula = z_end ~ z + z2, data = z_data2) z_model$coefficients    (Intercept) z z2 0.0005194086 3.6003271165 -0.1800141078    From the regression, we see that we have values , , and . Based on those values, we could construct a sequence using the recursive equation . Our original sequence data only showed two decimal places in the values, so we should think of our coefficients as having their own uncertainty. Let's compare what happens with the sequence using those estimated values with another sequence using the very similar . The code below also illustrates how we can format a table.   # Model parameters a <- -0.180014 a2 <- -0.18 b <- 3.600327 b2 <- 3.6 c <- 0.0005194 # Initial value z0 <- 1.00 num_pts <- 10 # Build the sequences z and u z <- double(num_pts + 1) u <- double(num_pts + 1) z[1] <- z0 u[1] <- z0 for (n in 1:num_pts) { z[n+1] <- c + b * z[n] + a * z[n]^2 u[n+1] <- b2 * u[n] + a2 * u[n]^2 } # Layout a table showing the values my_data <- tibble(t = 0:num_pts, z = z, u = u) print(my_data)    # A tibble: 11 × 3 t z u <int> <dbl> <dbl> 1 0 1 1 2 1 3.42 3.42 3 2 10.2 10.2 4 3 18.0 18.0 5 4 6.50 6.50 6 5 15.8 15.8 7 6 12.0 11.9 8 7 17.3 17.3 9 8 8.38 8.37 10 9 17.5 17.5 11 10 7.80 7.82    Perhaps surprisingly, the rounded model did better than the fitted values. Why would this happen? The actual values of the original sequence, which I generated with a computer using the simplified parameters, were rounded in order to present them with two decimal places. Thus our starting sequence had built-in errors. When we calculated our parameters using the linear model, we did in fact find the model that matched our results with the least squared errors for the rounded sequence. However, the fitted equation did not reproduce the sequence because it actually models a nearby sequence. If we had worked with more decimal values in the original sequence, we would have found a closer model.  To close the topic, the two projection functions will be visually indistinguishable in a figure. So the code below generates the graph of the original sequence as points coupled with a smooth graph showing the projection function.   library(tidyr) # for tibble library(ggplot2) # for ggplot # Original sequence z <- c(1.00, 3.42, 10.21, 17.99, 6.50, 15.80, 11.95, 17.32, 8.37, 17.52, 7.82) # Create the before\/after pairings z_proj_data <- tibble(z_start = z[1:10], z_end = z[2:11]) # Data for the projection function x <- seq(from = 0, to = 20, length=200) y <- 3.6 * x - 0.18 * x^2 # Create a plot with sequential values (P_n,P_(n+1)) and y=f(x) ggplot(data = NULL, # different data for different layers mapping = aes(x = z_start, y = z_end, color = \"sequence\")) + geom_point(data = z_proj_data, size=3) + geom_path(mapping = aes(x = x, y = y, color = \"projection\")) + scale_color_manual(values=c(\"sequence\"=\"blue\", \"projection\"=\"black\"))        "
},
{
  "id": "projection-fixed-points-2",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "equilibrium "
},
{
  "id": "projection-fixed-points-4",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "fixed points "
},
{
  "id": "projection-fixed-points-5",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-5",
  "type": "Example",
  "number": "2.4.15",
  "title": "",
  "body": "  Recall that Newton's method for finding the square root introduced the projection function . Find all of the fixed points for this function.    We are solving the fixed point equation which becomes . Solving this equation by hand corresponds to the following steps. So the fixed points are the positive and negative square roots of .   "
},
{
  "id": "projection-fixed-points-6",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-6",
  "type": "Example",
  "number": "2.4.16",
  "title": "",
  "body": "  A population has a per capita net growth rate that linearly decreases with the population, . Find the projection function and identify possible equilibria for this population.    The per capita net growth rate is related to the change in the population through births and deaths: . As a difference equation, the population can be modeled as . Using the given formula for , we can rewrite our model in recursive form as A projection function corresponds to the function in the equation , which we can recognize in this problem involves .  The fixed point equation allows us to find all fixed points (and therefore possible equilibria of the population). We solve the equation by factoring: By factoring an equation equal to zero, we find either (a fixed point) or (a simpler equation to find another fixed point). The other fixed point is . So the possible equilibria for this population model are the values or . (Notice how we interpreted in the context of the state variable rather than the fixed point variable .)   "
},
{
  "id": "projection-fixed-points-8",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "locally stable locally unstable "
},
{
  "id": "projection-fixed-points-9",
  "level": "2",
  "url": "population-projection.html#projection-fixed-points-9",
  "type": "Example",
  "number": "2.4.17",
  "title": "",
  "body": "  Find the fixed points for the projection function . Use numerical evidence to determine if each fixed point is locally stable or unstable.    We start by looking for fixed points algebraically. A fixed point is a solution to the equation . Using the formula of the projection function, the relevant equation is . Even though is a common factor, avoid the temptation to divide it out. This is a sure-fire way to lose an important solution. Instead, it is better to adopt a strategy solving using factoring. From this factored equation, we see solutions occur when or when . That is, is one fixed point. Solving results in a second fixed point .  To see if a fixed point is locally stable or unstable, we can get some numerical intuition by looking at sequence solutions that start relatively close to the fixed point. The first constructed sequence will look at the fixed point .   N <- 20 # Number of values we calculate # One sequence will have the fixed point as initial value fp_seq <- double(N+1) # Another sequence will be close nearby_seq <- double(N+1) # Define a projection function as a function project_fcn <- function(x) { 1.3*x - 0.05*x^2 } # Do two sequences at the same time fp_seq[1] <- 0 # At the fixed point nearby_seq[1] <- 0.1 # Just above the fixed point for (n in 1:N) { fp_seq[n+1] <- project_fcn( fp_seq[n] ) nearby_seq[n+1] <- project_fcn( nearby_seq[n] ) } # Organize into a tibble dataframe so both can be plotted together library(tidyr) library(dplyr) library(ggplot2) seq_data <- tibble(t = 0:N, fp = fp_seq, nearby = nearby_seq) # Combine fp and nearby into same common to be tidy style, then plot pivot_longer(seq_data, cols = c(fp, nearby), values_to = \"value\", names_to = \"sequence\") |> ggplot(mapping = aes(x = t, y = value, color = sequence)) + geom_point()     From the result, we see that the sequence that started just off the fixed point had sequence values the moved away from the fixed point sequence. This is strong evidence that the fixed point is locally unstable. It is not definitive because this one example doesn't show whether an even closer starting value might instead move toward the fixed point.  We next consider the fixed point at . Again, we visualize the fixed point sequence along with a sequence that starts nearby.   N <- 20 # Number of values we calculate # One sequence will have the fixed point as initial value fp_seq <- double(N+1) # Another sequence will be close nearby_seq <- double(N+1) # Define a projection function as a function project_fcn <- function(x) { 1.3*x - 0.05*x^2 } # Do two sequences at the same time fp_seq[1] <- 6 # At the fixed point nearby_seq[1] <- 6.1 # Just above the fixed point for (n in 1:N) { fp_seq[n+1] <- project_fcn( fp_seq[n] ) nearby_seq[n+1] <- project_fcn( nearby_seq[n] ) } # Organize into a tibble dataframe so both can be plotted together library(tidyr) library(dplyr) library(ggplot2) seq_data <- tibble(t = 0:N, fp = fp_seq, nearby = nearby_seq) # Combine fp and nearby into same common to be tidy style, then plot pivot_longer(seq_data, cols = c(fp, nearby), values_to = \"value\", names_to = \"sequence\") |> ggplot(mapping = aes(x = t, y = value, color = sequence)) + geom_point()     In this case, we see that the sequence that started just off the fixed point had sequence values the moved toward the fixed point sequence. This is strong evidence that the fixed point might be locally stable. It is not definitive all sequences that start sufficiently close need to demonstrate this behavior. We are only able to inspect a few at a time through graphs.   "
},
{
  "id": "projection-analysis",
  "level": "1",
  "url": "projection-analysis.html",
  "type": "Section",
  "number": "2.5",
  "title": "Analysis of Population Projections",
  "body": " Analysis of Population Projections   When we introduced projection functions that define a sequence recursively, , we discussed the relationship between fixed points of the projection function and equilibria of the sequence being studied. In this section, we will consider the analysis of projection functions in order to study the stability of equilibria. A stable equilibrium is likely to be observed in a physical setting. An unstable equilibrium is unlikely to be observed as small deviations from equilibrium push the system away from the steady state.  We will first consider a prototype example, where the projection function is a linear function. That system generalizes the geometric sequence related to constant per capita growth. For more complex models, we will then discuss using a linear approximation near the fixed point (i.e., a tangent line) to analyze equilibrium stability. We conclude with a graphical representation of sequences generated by projection functions that is commonly referred to as a cobweb diagram.    Linear Projection Functions  We begin by considering the consequence of using a linear function as a projection function. Mathematics texts usually introduce linear functions using the slope intercept form, where and are model parameters (slope and intercept). However, we will more frequently use the point slope form, , which has slope and passes through a point , or more precisely, . As an additional warning, note in advance that we will often use symbols other than to represent slope.   Consider a population model that uses a constant per capita growth rate for which we introduce an emigration term that is constant, say (for migration). Then our population model would be . Using sequences, this would be written . The projection function for this model is linear with a slope given by .     Consider a population that is decreasing by 5% per year. Suppose an intervention is established that supplements the population by 100 new individuals per year.  Express a recursive sequence model for this population and identify the projection function.    The recursive model for the population is motivated by the descriptive equation . If is the population after years, then our recursive model is We identify the projection function as , which is linear with slope .      A loan balance grows by of the annual percentage rate each month. But a monthly payment reduces the loan balance. Write down a recursive model for the loan balance where is the number of months since the loan began, is the annual percentage rate and is the amount of the monthly payment.    The recursive model for the loan balance is motivated by the descriptive equation . Our recursive model is The projection function is therefore , which is linear with slope .    The first step in analysis is to identify the fixed points which we use to rewrite our function. A linear projection function for constants (alpha) and (beta) has exactly one fixed point so long as . Recall that a fixed point is a solution to the equation : Because it is a fixed point, we know and the slope is . Rewriting in point slope form, we find the alternative representation .  The new representation allows us to rewrite our recursive equation for the sequence. Suppose that refers to a sequence generated by the projection function . Using the new representation, this becomes . This is equivalent to the equation . If we define a new sequence as the difference between and the fixed point , , then our equation is showing that the difference is a geometric sequence, . Geometric sequences have an explicit formula , which leads to an explicit formula for given by . For this reason, I call such sequences a shifted geometric sequence , where the sequence has been shifted to be centered around the fixed point .  Now that we have an explicit formula for our sequence, we can analyze the stability. The geometric sequence corresponds to repeated multiplication by the same number . When (negative), the sings of alternate between positive and negative. When , the sequence grows in magnitude; when , the magnitude of converges to zero.   Stability of Fixed Points for Linear Projection Functions   For a projection function with fixed point , the stability of the fixed point as an equilibrium for a sequence defined as is determined by the value of the slope .  If , then every sequence converges and is a locally stable equilibrium.  If , then every sequence with diverges away from and is a locally unstable equilibrium.  If , then the sequence alternates between two values and is neutrally stable as the sequence does not diverge.  If and ( ), then every number is a fixed point. If , then no fixed point exists.       Explore the results of the theorem through the interactive activity below. The figure below includes slides with which you will be able to choose the slope , the initial value and the desired fixed point . The first few terms of the result sequence defined by with initial value will then be shown. The equilibrium value is shown with a dashed line.   Graph showing a shifted geometric sequence    Did you observe the following features?  When , the sequence runs away from the equilibrium, staying on the same side as the initial value.  When , the sequence runs toward the equilibrium from the same side as the initial value.  When , the sequence runs toward the equilibrium but alternating sides.  When , the sequence runs away the equilibrium but alternating sides.       Linearizing Projection Functions  Most functions are not linear, so it might seem that the previous results are limited to just a few special cases. However, one of the basic premises of calculus is that many functions can be approximated by linear functions locally. That linear function corresponds to the tangent line , which exists so long as the function is differentiable .    If a function is differentiable at ( exists), then we can define the linear approximation of around . The linearization is the linear function with slope and passing through the point given by . When is sufficiently close to , the functions are nearly indistinguishable.    The tangent line equation is a consequence of standard calculus definitions. To clarify the idea of sufficiently close without trying to recreate an entire course in analysis, let us start by pointing out that because exists, the average rate of change defined by must converge to as approaches , as given in the limit . This is equivalent to saying . This can be rewritten as . Because the denominator goes to zero, the numerator must go to zero even faster for the limit to equal zero.    Now, suppose that we are working with a projection function with a fixed point at . This means that . The tangent line of the projection function around the fixed point will be . By construction, we know that is a fixed point of the linearized projection function and the stability of the fixed point as an equilibrium is determined by the slope . The following theorem guarantees that so long as , the stability of the fixed point for the projection function is the same as the linearized function. (There is no clear conclusion if .)   Stability of Fixed Points for Projection Functions   Suppose a projection function has a fixed point at and exists. So long as , the local stability of the fixed point is determined by the value of as follows.  If , then is a locally stable fixed point.  If , then is a locally unstable fixed point.       Computer Assisted Analysis  This course has the assumption that you have completed a first semester university calculus course. Therefore, it is assumed that you are able to calculate basic derivatives and integrals. However, there are many computational tools available that can compute these directly and help us avoid mistakes. Here, I introduce you to one such service called SageMath that supports an open-source mathematical programming language called Sage. You can get a blank Sage cell in which you can perform computations at the following link: . Note that from this site, you are actually able to choose from a variety of different languages. When doing algebraic manipulation of formulas as described here, be sure to choose the language Sage . This text embeds Sage cells within the document with the language set by default. (We have seen previous SageMath cells with the language set to R previously.)  Sage is built on top of Python, and any valid Python code can be included with Sage commands. In our work with R, we have stored results in variables that represent memory locations to keep track of data. Sage allows us to create objects that represent constants, variables, and formulas in a mathematical sense. We then can manipulate those mathematical objects.  Suppose we wanted to consider a projection function . The tasks we want to accomplish are as follows:  Define our projection formula.  Solve for the fixed points of the formula.  Calculate the derivative of the projection formula.  Evaluate the derivative at each identified fixed point.  After we see the mathematical results, we will apply to determine stability.  The process of defining a formula in Sage requires first declaring all math symbols that will be variables. In our example, the only variable is . Sometimes we might have parameters that we leave in symbolic form and they would also need to be declared. The Sage command for declaring a variable is the function var(...) , where the input consists of variable names in quotes and separated by commas. This command must be evaluated before we start using the symbols in a formula. For our problem, we will use the command var(\"x\") .  To actually define our expression, we need to choose a name for the expression for later reference as a programming variable name. Where R prefers that we use the assignment operators <- or -> , Python (and therefore Sage) requires the assignment operator is always = , with the variable name on the left side of the statement. To declare our example as my_projection we would type the statement my_projection = x + 0.2*x*(1-0.05*x) . Notice how we need to explicitly type * for multiplication.  Sage is able to solve basic algebraic equations directly using the command solve(...) . In the current problem, there is only one equation, but because we often want to solve a system of equations, we will put a list of equations with only one list inside square brackets. Because = is used for variable assignment, most computer languages including Python and R use a double equal == for creating equations that are true or false. A solution will be a specific value of the variable , so we also need to specify what we are solving for. In the future, we will again be solving for multiple variables, we will again use a list of variables we are solving to find. Because we are solving , the basic command will therefore be solve([my_projection == x], [x]) , and it returns a list of equations that solve the problem.  Just as solve was the command to solve an equation, we will use a command derivative to find the derivative of our formula. Because there are potentially many symbols representing variables, we need to specify the symbol for the independent variable as part of the command. To differentiate with respect to , we tell our expression object my_projection to perform an action derivative with respect to using the syntax my_projection.derivative(x) . If the variable was something other than , we just change that part of the formula.  We will store the results of solving the equation and finding the derivative so that we can use the results later. The last thing we need to do is to evaluate the derivative at the point of the solution to the fixed point equation. Suppose we named the result of our derivative f_prime . We need to tell that object to make a substitution using the subs command. We can also ask that the result is simplified as much as possible. Since we want to do this for each fixed point solution, we will do this step in a loop.  The entire structure of our analysis is accomplished with the following commands.   The previous code will show formulas giving and . It identifies fixed points at and . Surprisingly, when evaluating , it gives a value . This is a consequence of computers being unable to represent numbers in decimal form exactly. If you changed the code to use 2\/10 instead of 0.2 and 5\/1000 instead of 0.005 , you will get exact results. That is, we find that and .  It is our task to interpret the results. Because the slope of the projection function at the fixed point is greater than 1, the fixed point is a locally unstable fixed point. However, because has a value 0.8 which is positive and less than 1, the fixed point is locally stable. If a population starts small and close to , the subsequent population values will move farther away from 0. (This is good for a population as it is increasing in size.) On the other hand, a population that is close to 200 will move closer to 200, as that fixed point is stable. The population value of 200 acts as a carrying capacity .   "
},
{
  "id": "linear-projection-analysis-3",
  "level": "2",
  "url": "projection-analysis.html#linear-projection-analysis-3",
  "type": "Example",
  "number": "2.5.1",
  "title": "",
  "body": " Consider a population model that uses a constant per capita growth rate for which we introduce an emigration term that is constant, say (for migration). Then our population model would be . Using sequences, this would be written . The projection function for this model is linear with a slope given by .  "
},
{
  "id": "linear-projection-analysis-4",
  "level": "2",
  "url": "projection-analysis.html#linear-projection-analysis-4",
  "type": "Example",
  "number": "2.5.2",
  "title": "",
  "body": "  Consider a population that is decreasing by 5% per year. Suppose an intervention is established that supplements the population by 100 new individuals per year.  Express a recursive sequence model for this population and identify the projection function.    The recursive model for the population is motivated by the descriptive equation . If is the population after years, then our recursive model is We identify the projection function as , which is linear with slope .   "
},
{
  "id": "linear-projection-analysis-5",
  "level": "2",
  "url": "projection-analysis.html#linear-projection-analysis-5",
  "type": "Example",
  "number": "2.5.3",
  "title": "",
  "body": "  A loan balance grows by of the annual percentage rate each month. But a monthly payment reduces the loan balance. Write down a recursive model for the loan balance where is the number of months since the loan began, is the annual percentage rate and is the amount of the monthly payment.    The recursive model for the loan balance is motivated by the descriptive equation . Our recursive model is The projection function is therefore , which is linear with slope .   "
},
{
  "id": "linear-projection-analysis-7",
  "level": "2",
  "url": "projection-analysis.html#linear-projection-analysis-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "shifted geometric sequence "
},
{
  "id": "thm-linear-projection-stability",
  "level": "2",
  "url": "projection-analysis.html#thm-linear-projection-stability",
  "type": "Theorem",
  "number": "2.5.4",
  "title": "Stability of Fixed Points for Linear Projection Functions.",
  "body": " Stability of Fixed Points for Linear Projection Functions   For a projection function with fixed point , the stability of the fixed point as an equilibrium for a sequence defined as is determined by the value of the slope .  If , then every sequence converges and is a locally stable equilibrium.  If , then every sequence with diverges away from and is a locally unstable equilibrium.  If , then the sequence alternates between two values and is neutrally stable as the sequence does not diverge.  If and ( ), then every number is a fixed point. If , then no fixed point exists.     "
},
{
  "id": "linear-projection-analysis-10",
  "level": "2",
  "url": "projection-analysis.html#linear-projection-analysis-10",
  "type": "Example",
  "number": "2.5.5",
  "title": "",
  "body": " Explore the results of the theorem through the interactive activity below. The figure below includes slides with which you will be able to choose the slope , the initial value and the desired fixed point . The first few terms of the result sequence defined by with initial value will then be shown. The equilibrium value is shown with a dashed line.   Graph showing a shifted geometric sequence    Did you observe the following features?  When , the sequence runs away from the equilibrium, staying on the same side as the initial value.  When , the sequence runs toward the equilibrium from the same side as the initial value.  When , the sequence runs toward the equilibrium but alternating sides.  When , the sequence runs away the equilibrium but alternating sides.    "
},
{
  "id": "projection-analysis-4-2",
  "level": "2",
  "url": "projection-analysis.html#projection-analysis-4-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "tangent line differentiable "
},
{
  "id": "thm-function-linearization",
  "level": "2",
  "url": "projection-analysis.html#thm-function-linearization",
  "type": "Theorem",
  "number": "2.5.7",
  "title": "",
  "body": "  If a function is differentiable at ( exists), then we can define the linear approximation of around . The linearization is the linear function with slope and passing through the point given by . When is sufficiently close to , the functions are nearly indistinguishable.    The tangent line equation is a consequence of standard calculus definitions. To clarify the idea of sufficiently close without trying to recreate an entire course in analysis, let us start by pointing out that because exists, the average rate of change defined by must converge to as approaches , as given in the limit . This is equivalent to saying . This can be rewritten as . Because the denominator goes to zero, the numerator must go to zero even faster for the limit to equal zero.   "
},
{
  "id": "thm-projection-fixed-point-stability",
  "level": "2",
  "url": "projection-analysis.html#thm-projection-fixed-point-stability",
  "type": "Theorem",
  "number": "2.5.8",
  "title": "Stability of Fixed Points for Projection Functions.",
  "body": " Stability of Fixed Points for Projection Functions   Suppose a projection function has a fixed point at and exists. So long as , the local stability of the fixed point is determined by the value of as follows.  If , then is a locally stable fixed point.  If , then is a locally unstable fixed point.    "
},
{
  "id": "projection-analysis-5-3",
  "level": "2",
  "url": "projection-analysis.html#projection-analysis-5-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "variables "
},
{
  "id": "projection-analysis-5-7",
  "level": "2",
  "url": "projection-analysis.html#projection-analysis-5-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "system "
},
{
  "id": "projection-analysis-5-13",
  "level": "2",
  "url": "projection-analysis.html#projection-analysis-5-13",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "carrying capacity "
},
{
  "id": "projection-cobweb",
  "level": "1",
  "url": "projection-cobweb.html",
  "type": "Section",
  "number": "2.6",
  "title": "Graphical Analysis of Projection Functions",
  "body": " Graphical Analysis of Projection Functions   A projection function establishes a relationship between consecutive values in a sequence. For a population, the projection function allows us to predict the population after one cycle given the size of the population at the current time. In this section, we will learn how to interpret information using the graph of the projection function.    Visualizing Potential for Growth  In calculus, we learn that a function is increasing on intervals for which and decreasing on intervals for which . This is because the derivative of a function measures the rate of change for the function . Sequences can be analyzed in a similar way, by looking at whether increments in the sequence are positive or negative.  The increment for a sequence is the difference between consecutive terms, defined by the backward difference We call it the increment because the increment is what we add to the current value to find the next value of the sequence, For populations, the increment corresponds to the sum of births and net migration minus the deaths.  When a population model involves a projection function , then the increment depends on the value of the function , Consequently, we can identify when the population will grow or decline based on the value of . When , the sequence increases. When , the sequence decreases.   Consider a model for population growth where the per capita net growth rate is a decreasing linear function of the population size, . The projection function for this model is given by The fixed points for this are and . The second fixed point is often denoted by , and the per capita growth can then written in the equivalent form . This model is called the discrete logistic model for population growth.  We consider the case when so that . A graph of is illustrated below. The graph is a concave down parabola with intercepts at and . We see that is positive for in the interval and negative in the intervals and . In the context of population growth, the negative interval has no physical interpretation. (In other contexts, the same model might apply and have an interpretation.) So the population will increase whenever and will decrease whenever .       The equilibrium value is called the carrying capacity , representing the population that the environment can sustain. When the population is below carrying capacity, the environment can sustain growth in the population. However, when the population is above the carrying capacity, the environment puts so much pressure on the population that the next cycle results in a smaller population.   It is often better to graph and on the same graph. Growth in the population will correspond to intervals over which and decay occurs on intervals where . We can think of the line as the projection that would be required for exact replacement. Anytime the projection function is above this line, the population exceeds replacement. Anytime the projection function is below this line, the population falls. Points where the graphs intersect are fixed points and correspond to the equilibrium values of the sequence. In addition, such a graph allows us to analyze a sequence using something called a cobweb diagram.    Cobweb Diagrams  A cobweb diagram illustrates the dynamics of a sequence through its projection function by drawing a sequence of vertical and horizontal lines that represent the projection process. A cobweb diagram always begins with a graph showing both the projection function and the line of exact replacement . Recall that a projection function takes a sequence value as input ( -value) and the output ( -value) gives the next value in the sequence. The steps in generating a cobweb diagram are explained below.  Initial Value On the -axis, identify the location of the initial value and start on the line . Your current point will be .  Project Next Value Draw a vertical line between your current point and the projection graph . The -value of the new point will be the next sequence value.  Update Current Value Draw a horizontal line between your last point and the line . The new -value now corresponds to the next value of your sequence.  Repeat Repeat the steps of projecting and updating. Vertical lines always end at the projection function; horizontal lines always end at .    Compare the cobweb diagrams for a discrete logistic population model with (to represent 1 capacity unit, not 1 individual) and values and using initial values . The projection function when is given by . When , the projection function is .  First, we consider the cobweb diagram for . The figure below is interactive in that you can see the repetition in drawing the segments of the diagram. For this projection function and initial value, the sequence steadily increases toward the fixed point. We can see that the fixed point is stable.     Next we look at the cobweb diagram for . In this example, the vertex of the parabola is to the left of the fixed point so that our sequence actually exceeds the carrying capacity and begins to oscillate above and below the equilibrium. However, it does still eventually converge to the fixed point.     Because we can, here is a figure where you can choose the value of ( ) and the initial value and explore a variety of cobweb diagrams in a single figure. Notice in particular that when the value of is larger, so that the peak of the parabola is higher, the dynamics become more complex.      The code below generates the graph of and in preparation for a cobweb diagram in Sage, with the benefit that the resulting graphic can be copied for other uses.   Building on the figure above, you can then add a particular cobweb diagram corresponding to an initial value of your choice.     Cobwebs and Stability  We conclude the section by combining the concepts of cobweb diagrams and stability. Recall that our criteria for local stability depended on the slope of the tangent line at the fixed point. Suppose that is a fixed point so that . A cobweb diagram of the linear approximation around the fixed point behaves in one of the following four ways.  If , then the cobweb diagram moves away from the fixed point like a staircase and the fixed point is unstable.  If , then the cobweb diagram moves toward the fixed point and the fixed point is stable.  If , then the cobweb diagram spirals inward toward the fixed point and the fixed point is stable.  If , then the cobweb diagram spirals outward away from the fixed point and the fixed point is stable.  More complicated dynamics can occur further away from the fixed point. But at least near the fixed point, the linear approximation gives a good description of what is happening, at least when .  A dynamic cobweb diagram of a linear projection function where you can choose the slope at the fixed point is illustrated below. Can you relate this behavior to what you observed in the discrete logistic model earlier?      "
},
{
  "id": "projection-compare-replacement-5",
  "level": "2",
  "url": "projection-cobweb.html#projection-compare-replacement-5",
  "type": "Example",
  "number": "2.6.1",
  "title": "",
  "body": " Consider a model for population growth where the per capita net growth rate is a decreasing linear function of the population size, . The projection function for this model is given by The fixed points for this are and . The second fixed point is often denoted by , and the per capita growth can then written in the equivalent form . This model is called the discrete logistic model for population growth.  We consider the case when so that . A graph of is illustrated below. The graph is a concave down parabola with intercepts at and . We see that is positive for in the interval and negative in the intervals and . In the context of population growth, the negative interval has no physical interpretation. (In other contexts, the same model might apply and have an interpretation.) So the population will increase whenever and will decrease whenever .       The equilibrium value is called the carrying capacity , representing the population that the environment can sustain. When the population is below carrying capacity, the environment can sustain growth in the population. However, when the population is above the carrying capacity, the environment puts so much pressure on the population that the next cycle results in a smaller population.  "
},
{
  "id": "projection-compare-replacement-6",
  "level": "2",
  "url": "projection-cobweb.html#projection-compare-replacement-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "fixed points "
},
{
  "id": "cobweb-diagrams-2",
  "level": "2",
  "url": "projection-cobweb.html#cobweb-diagrams-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "cobweb diagram "
},
{
  "id": "cobweb-diagrams-3",
  "level": "2",
  "url": "projection-cobweb.html#cobweb-diagrams-3",
  "type": "Example",
  "number": "2.6.3",
  "title": "",
  "body": " Compare the cobweb diagrams for a discrete logistic population model with (to represent 1 capacity unit, not 1 individual) and values and using initial values . The projection function when is given by . When , the projection function is .  First, we consider the cobweb diagram for . The figure below is interactive in that you can see the repetition in drawing the segments of the diagram. For this projection function and initial value, the sequence steadily increases toward the fixed point. We can see that the fixed point is stable.     Next we look at the cobweb diagram for . In this example, the vertex of the parabola is to the left of the fixed point so that our sequence actually exceeds the carrying capacity and begins to oscillate above and below the equilibrium. However, it does still eventually converge to the fixed point.     Because we can, here is a figure where you can choose the value of ( ) and the initial value and explore a variety of cobweb diagrams in a single figure. Notice in particular that when the value of is larger, so that the peak of the parabola is higher, the dynamics become more complex.     "
},
{
  "id": "projection-cobweb-5-4",
  "level": "2",
  "url": "projection-cobweb.html#projection-cobweb-5-4",
  "type": "Figure",
  "number": "2.6.7",
  "title": "",
  "body": "  "
},
{
  "id": "population-interventions",
  "level": "1",
  "url": "population-interventions.html",
  "type": "Section",
  "number": "2.7",
  "title": "Intervention and Bifurcations",
  "body": " Intervention and Bifurcations   It is often the case that an outside influence affects a population. A population of economic value might be harvested for resource consumption. A species that is deemed harmful might have outside efforts to control or eradicate the population. Endangered populations may be influenced by conservation efforts to modify the birth or death rates or to supplement natural population growth through artificial migration. Mathematical models can often help us understand some of the impacts of these interventions on a population.  This section will suggest some of the ways that we can analyze the effects of interventions on a population. These interventions often are targeted at changing the growth rate, and analysis can explore if changes to the mathematical model will lead to such changes in population growth. We will use harvesting as a specific intervention to motivate our discussion.  Consider a population that prior to any intervention can be modeled as a sequence with a projection function , We are interested in the changes to the model when we introduce harvesting. Harvesting corresponds to removing additional individuals from the population than occur naturally through death and emigration. If we let be the sequence for the number of individuals harvested during the st cycle for the population, then the new model for our sequence will be defined through  The two simplest models for harvesting correspond to a constant harvesting rate and a proportional harvesting rate. A constant harvesting rate occurs when the same number of individuals are removed from the population during each cycle, independent of the current size of the population. A proportional harvesting rate occurs when the harvesting efforts remove a number of individuals that is proportional to the population size. This model is often used to approximate what happens when harvesting effort is constant but success in capturing an individual is proportional to the population size. Other models might also be formed that capture the idea that it is harder to find individuals to harvest when the population is small with nonlinear functions.  In addition, we will explore the effect of intervention on the potential equilibrium values of the model as well as the stability of those equilibria. Such fundamental changes in the behavior of the model are known as bifurcations , and this section will introduce some examples of bifurcations.    Constant Harvesting  The constant harvesting rate results in a model where is the number of individuals harvested per cycle. In the context of the graphical analysis of the projection function, this corresponds to shifting the graph of the projection function vertically downward by the value of . This changes the values of fixed points and for large enough values of make the fixed points vanish.   Consider the discrete logistic model with projection function The natural fixed points for this model are at and at . Once constant harvesting is introduced, the modified projection function is given by .  The fixed points are the solution to the quadratic equation The solutions are given by the quadratic formula When , we recover the unperturbed fixed points. As increases, the expression inside the square root, , decreases until it equals zero when . For any value of , there are no fixed points, a catastrophic result for the population that is predicted to decrease indefinitely.  You should note that for , is no longer a fixed point. Mathematically, even though there are no individuals, the model still harvests individuals resulting in a negative population. Although this does not make physical sense, it is biologically significant for very small populations. It would indicate that for small enough populations, constant harvesting would eradicate the population in a single step. And for populations that are below the lower fixed point, the population would be decreasing steadily towards this same fate.  You can explore the cobweb diagram for this situation for the discrete logistic model with and and varying values for . The bifurcation occurs when . Notice that if your initial condition is below the lower fixed point, the population will die off. Also notice that if is above the bifurcation value, there is no population that will be able to survive.      When working with bifurcations, it is often useful to create a bifurcation diagram . For the example above, our bifurcation diagram might show the values of the fixed points as they depend on the value of . In addition, by changing the line style of the graph, we can indicate the local stability of the fixed points. For the parameter values used, the upper fixed point was stable so long as it existed and the lower fixed point was unstable. The following Sage code generates a graph that we can use.   This type of bifurcation where two fixed points with opposite stability merge and subsequently vanish is called a saddle node bifurcation . The bifurcation itself occurs at the parameter value where the two fixed points coalesce.    Proportional Harvesting  The proportional harvesting rate results in a model where is the proportionality constant of . For small populations, there will be small numbers harvested; for large populations, there will be large numbers harvested. If has a fixed point at , the harvesting model will also have that fixed point. The following example considers the effect of proportional harvesting on the discrete logistic model.   Again consider the discrete logistic model with projection function with fixed points at and at . With proportional harvesting, the modified projection function is given by .  The fixed point equation can be rewritten in an equivalent factored form The fixed points of the perturbed model are and . When , the second fixed point corresponds to our original value . As increases, location of the second fixed point steadily decreases. When , the two fixed points overlap, and when , the second fixed point is a negative value.  You can explore the cobweb diagram for this situation for the discrete logistic model with and and varying values for . The bifurcation occurs when . Notice that if your initial condition is between the two fixed points, the population increase. But if the harvesting rate exceeds the intrinsic per capita net growth rate , then the population converges to an extinct state.      Before generating a bifurcation diagram, let us consider the stability of our fixed points. The projection function that includes harvesting is given by The derivative is given by Finding the slope at the fixed points, and , we find Consequently, we see that is locally unstable when . That is, a small population will be able to grow so long as the per capita net growth rate exceeds the per capita harvesting rate. However, once , the slope has value less than 1 and the fixed point is stable. This means that a small population will converge towards extinction. (A population does not want extinction to be a stable equilibrium.) The other fixed point has the reverse stability. Note that it is possible for instability if , where the model would introduce unstable oscillations around the fixed point. For the parameters explored above, this does not happen.  The following Sage code generates a bifurcation diagram. Note that the plots for the fixed points are divided into two parts to capture the change in stability.   This type of bifurcation where two fixed points with opposite stability cross through one another and subsequently switch stability is called a transcritical bifurcation . The bifurcation itself occurs at the parameter value where the two fixed points coalesce, in this case when .   "
},
{
  "id": "population-interventions-2-5",
  "level": "2",
  "url": "population-interventions.html#population-interventions-2-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "bifurcations "
},
{
  "id": "population-constant-harvesting-3",
  "level": "2",
  "url": "population-interventions.html#population-constant-harvesting-3",
  "type": "Example",
  "number": "2.7.1",
  "title": "",
  "body": " Consider the discrete logistic model with projection function The natural fixed points for this model are at and at . Once constant harvesting is introduced, the modified projection function is given by .  The fixed points are the solution to the quadratic equation The solutions are given by the quadratic formula When , we recover the unperturbed fixed points. As increases, the expression inside the square root, , decreases until it equals zero when . For any value of , there are no fixed points, a catastrophic result for the population that is predicted to decrease indefinitely.  You should note that for , is no longer a fixed point. Mathematically, even though there are no individuals, the model still harvests individuals resulting in a negative population. Although this does not make physical sense, it is biologically significant for very small populations. It would indicate that for small enough populations, constant harvesting would eradicate the population in a single step. And for populations that are below the lower fixed point, the population would be decreasing steadily towards this same fate.  You can explore the cobweb diagram for this situation for the discrete logistic model with and and varying values for . The bifurcation occurs when . Notice that if your initial condition is below the lower fixed point, the population will die off. Also notice that if is above the bifurcation value, there is no population that will be able to survive.     "
},
{
  "id": "population-constant-harvesting-4",
  "level": "2",
  "url": "population-interventions.html#population-constant-harvesting-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "bifurcation diagram "
},
{
  "id": "population-constant-harvesting-6",
  "level": "2",
  "url": "population-interventions.html#population-constant-harvesting-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "saddle node bifurcation "
},
{
  "id": "population-interventions-4-3",
  "level": "2",
  "url": "population-interventions.html#population-interventions-4-3",
  "type": "Example",
  "number": "2.7.3",
  "title": "",
  "body": " Again consider the discrete logistic model with projection function with fixed points at and at . With proportional harvesting, the modified projection function is given by .  The fixed point equation can be rewritten in an equivalent factored form The fixed points of the perturbed model are and . When , the second fixed point corresponds to our original value . As increases, location of the second fixed point steadily decreases. When , the two fixed points overlap, and when , the second fixed point is a negative value.  You can explore the cobweb diagram for this situation for the discrete logistic model with and and varying values for . The bifurcation occurs when . Notice that if your initial condition is between the two fixed points, the population increase. But if the harvesting rate exceeds the intrinsic per capita net growth rate , then the population converges to an extinct state.     "
},
{
  "id": "population-interventions-4-7",
  "level": "2",
  "url": "population-interventions.html#population-interventions-4-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "transcritical bifurcation "
},
{
  "id": "intro-differential-equations",
  "level": "1",
  "url": "intro-differential-equations.html",
  "type": "Section",
  "number": "2.8",
  "title": "Introduction to Differential Equations",
  "body": " Introduction to Differential Equations   Sequences are useful for modeling quantities that change according to a regular cycle and we only need to predict or measure the quantity at the same moment in a cycle. For a population that has an annual reproductive cycle, we may only need to model the population size at a particular time each year. Even for populations that change continuously, we might only wish to model the value at regular intervals. We call these models discrete time models . However, we often desire models that give us functions describing a quantity of interest at arbitrary times and not just at discrete moments. Models that accomplish this are called continuous time models . Differential equation models are examples of continuous time models.    Rates of Change  In order to motivate differential equations, let us think back to population models where the population changed according to births and deaths. For discrete time models, we established functions that described how many births or deaths to add over the course of a cycle. Such a function represented the total accumulated births or deaths, regardless of exactly when those events occurred. For a continuous time model, we instead think in terms of the rate at which births and deaths are occurring.  A rate of change represents the ratio between the changes of two covarying variables. One of the simplest examples is velocity which is the rate of change of distance traveled with respect to time, for which you probably have heard the saying, distance equals rate times time. Mathematically, this is saying that the distance traveled is proportional to the time spent travelling and the rate (velocity) is the proportionality constant. However, this is technically only true for constant rates of change. Calculus introduced the derivative as the mathematical quantity that measures the instantaneous rate of change . This rate of change results from the idea of computing the limit of an average rate of change.  Consider a quantity that is a function of time . The instantaneous rate of change of with respect to at a particular moment is defined as the derivative Thinking of this in reverse, this is telling us that the value can approximately be found as That is, the increment of change in is approximately just the derivative times the increment of time. The approximation improves as the increment of time decreases and is exact in the limit.    Differential Equations  A differential equation is an equation that defines the rate of change (a derivative) for a quantity. Calculus classes often compute derivatives and write them with formulas involving the independent variable. These are technically differential equations, but they are not especially useful in modeling.   Given , we can find the derivative . This equation is a differential equation involving the independent variable . The original function is a solution to the differential equation because the differential equation is true for that function. However, is also a solution to the same differential equation. In general, the solution must be of the form for some constant . Solutions are not unique unless additional restrictions are provided. That is the purpose of the integration constant .   Differential equations in modeling occur when the formula that defines the rate of change is a function involving the dependent variable and not just the independent variable. To identify a unique solution, we also need an initial value.   The differential equation defines the rate of change using a formula involving the dependent variable . Recall that the exponential function has this behavior since . That is, since , we have just discovered that and are the same, which is precisely what the equation means.  In fact, will be a solution for any value of . The derivative, for this formula will be The value of depends on the initial value for the function.     Solutions to Differential Equations  There are many strategies for trying to solve differential equations. These strategies are taught in courses exclusively about differential equations. Our emphasis will be on creating models using differential equations and understanding the behavior of the solutions without requiring formulas as solutions. The following theorem guarantees that a differential equation with an initial value has a unique solution under reasonable conditions.   Existence and Uniqueness of Initial Value Problems   Suppose that represents a continuous function of both and such that exists and is bounded (i.e., small changes in should result in small changes in . Then the differential equation with initial value has a unique solution for some interval with .    The proof is outside the scope of this text but is based on the convergence of approximations.    Note that the existence-uniqueness theorem only guarantees that a solution will exist on an interval near the initial value. Sometimes, solutions exist on very short intervals. If the value of the function is very large, then the solution might run away to infinity. Other times, solutions might exist for all real numbers. The uniqueness property indicates that for any initial value, there can only be one solution.  Knowing that solutions exist, even if we can't find their formulas, we can turn to computers to help us approximate their values using numerical algorithms. One common numerical method will be to approximate the value of the solution at specific values. (Asking for the entire function is usually too much.) The following Sage examples illustrate how we might find such approximations.   Find numerical approximations for the solution of the differential equation with various initial values . The Sage script below allows you to vary the initial value and create a table of approximating values as well as generate a graph of the approximation.      Slope Fields  In addition to solving the differential equation numerically, we can explore a differential equation graphically through a plot called a slope field . Although a differential equation could be any equation that involves the derivative, in modeling we usually think of a differential equation in the form presented in the existence uniqueness theorem where the derivative is equal to an expression that depends on the independent and dependent variables, such as Because the value of the derivative represents a slope, this equation allows us to define what the slope would be at every point in the -plane.   Slope Field   A slope field is a geometric representation of a differential equation wherein every point in the plane is represented by a line segment at that point having the slope . Because every point is impossible to visualize, in practice the graph only shows the slope field at points on a grid of equally spaced points.    The solution to a differential equation with an initial value will be a function whose graph includes the point and then at every point has a tangent line that has the same slope as the slope field at that point. This means that the curve follows the direction of the arrows.  Computer packages allow us to easily generate slope fields. Evaluate the following Sage scripts to see a variety of different examples.   The differential equation has a rate formula that is constant. This means that every point has the same slope. Solutions will follow straight lines.   Note that there are infinitely many different solutions corresponding to a family of parallel lines with slope 3. Given any particular point (initial value), there will only be one of those lines passing through the point. That is the uniqueness of solutions of differential equations.    The differential equation has a rate formula . The rate formula in this case depends only on the independent variable . You should notice that the slope is the same at points that are on the same vertical line, .   In calculus, we learned that can be solved for using antiderivatives, where we get , where is a constant of integration. This corresponds to a horizontal translation or shift, which is the appropriate analogue for the parallel lines in the first example. That is, we should think of the lines in the first example as vertical shifts of one another.    The differential equation has a rate formula . The rate formula uses the same operations as the previous example but in terms of the dependent variable . You should notice that the slope is the same at points that are on the same horizontal line .   Notice that solutions are no longer vertical translations or shifts of one another. However, you should see that every solution will have corresponding solutions that are horizontal translations . Different curves correspond to different initial conditions. In this example, we can see that there are three basic classes of solutions. Above a certain point, the graphs grow without bound and head to infinity at some finite time. (This is an example of why the existence uniqueness theorem only guaranteed a solution for a limited interval.) Between two values that we will soon learn are equilibrium solutions, solutions form a transition from the upper equilibrium (unstable) to the lower equilibrium (stable). Solutions that begin below the lower equilibrium all rise and asymptotically approach the stable equilibrium.    The differential equation has a rate formula . Because this rate formula depends on both and , solutions do not share either horizontal or vertical translations.      "
},
{
  "id": "intro-differential-equations-2-1",
  "level": "2",
  "url": "intro-differential-equations.html#intro-differential-equations-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "discrete time models continuous time models "
},
{
  "id": "rate-of-change-3",
  "level": "2",
  "url": "intro-differential-equations.html#rate-of-change-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "rate of change derivative instantaneous rate of change "
},
{
  "id": "differential-equations-3",
  "level": "2",
  "url": "intro-differential-equations.html#differential-equations-3",
  "type": "Example",
  "number": "2.8.1",
  "title": "",
  "body": " Given , we can find the derivative . This equation is a differential equation involving the independent variable . The original function is a solution to the differential equation because the differential equation is true for that function. However, is also a solution to the same differential equation. In general, the solution must be of the form for some constant . Solutions are not unique unless additional restrictions are provided. That is the purpose of the integration constant .  "
},
{
  "id": "differential-equations-5",
  "level": "2",
  "url": "intro-differential-equations.html#differential-equations-5",
  "type": "Example",
  "number": "2.8.2",
  "title": "",
  "body": " The differential equation defines the rate of change using a formula involving the dependent variable . Recall that the exponential function has this behavior since . That is, since , we have just discovered that and are the same, which is precisely what the equation means.  In fact, will be a solution for any value of . The derivative, for this formula will be The value of depends on the initial value for the function.  "
},
{
  "id": "thm-diffeq-existence-uniqueness",
  "level": "2",
  "url": "intro-differential-equations.html#thm-diffeq-existence-uniqueness",
  "type": "Theorem",
  "number": "2.8.3",
  "title": "Existence and Uniqueness of Initial Value Problems.",
  "body": " Existence and Uniqueness of Initial Value Problems   Suppose that represents a continuous function of both and such that exists and is bounded (i.e., small changes in should result in small changes in . Then the differential equation with initial value has a unique solution for some interval with .    The proof is outside the scope of this text but is based on the convergence of approximations.   "
},
{
  "id": "numerical-solutions-diffeq-6",
  "level": "2",
  "url": "intro-differential-equations.html#numerical-solutions-diffeq-6",
  "type": "Example",
  "number": "2.8.4",
  "title": "",
  "body": " Find numerical approximations for the solution of the differential equation with various initial values . The Sage script below allows you to vary the initial value and create a table of approximating values as well as generate a graph of the approximation.   "
},
{
  "id": "slope-fields-2",
  "level": "2",
  "url": "intro-differential-equations.html#slope-fields-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "slope field "
},
{
  "id": "defn-slope-field",
  "level": "2",
  "url": "intro-differential-equations.html#defn-slope-field",
  "type": "Definition",
  "number": "2.8.5",
  "title": "Slope Field.",
  "body": " Slope Field   A slope field is a geometric representation of a differential equation wherein every point in the plane is represented by a line segment at that point having the slope . Because every point is impossible to visualize, in practice the graph only shows the slope field at points on a grid of equally spaced points.   "
},
{
  "id": "slope-fields-6",
  "level": "2",
  "url": "intro-differential-equations.html#slope-fields-6",
  "type": "Example",
  "number": "2.8.6",
  "title": "",
  "body": " The differential equation has a rate formula that is constant. This means that every point has the same slope. Solutions will follow straight lines.   Note that there are infinitely many different solutions corresponding to a family of parallel lines with slope 3. Given any particular point (initial value), there will only be one of those lines passing through the point. That is the uniqueness of solutions of differential equations.  "
},
{
  "id": "slope-fields-7",
  "level": "2",
  "url": "intro-differential-equations.html#slope-fields-7",
  "type": "Example",
  "number": "2.8.7",
  "title": "",
  "body": " The differential equation has a rate formula . The rate formula in this case depends only on the independent variable . You should notice that the slope is the same at points that are on the same vertical line, .   In calculus, we learned that can be solved for using antiderivatives, where we get , where is a constant of integration. This corresponds to a horizontal translation or shift, which is the appropriate analogue for the parallel lines in the first example. That is, we should think of the lines in the first example as vertical shifts of one another.  "
},
{
  "id": "slope-fields-8",
  "level": "2",
  "url": "intro-differential-equations.html#slope-fields-8",
  "type": "Example",
  "number": "2.8.8",
  "title": "",
  "body": " The differential equation has a rate formula . The rate formula uses the same operations as the previous example but in terms of the dependent variable . You should notice that the slope is the same at points that are on the same horizontal line .   Notice that solutions are no longer vertical translations or shifts of one another. However, you should see that every solution will have corresponding solutions that are horizontal translations . Different curves correspond to different initial conditions. In this example, we can see that there are three basic classes of solutions. Above a certain point, the graphs grow without bound and head to infinity at some finite time. (This is an example of why the existence uniqueness theorem only guaranteed a solution for a limited interval.) Between two values that we will soon learn are equilibrium solutions, solutions form a transition from the upper equilibrium (unstable) to the lower equilibrium (stable). Solutions that begin below the lower equilibrium all rise and asymptotically approach the stable equilibrium.  "
},
{
  "id": "slope-fields-9",
  "level": "2",
  "url": "intro-differential-equations.html#slope-fields-9",
  "type": "Example",
  "number": "2.8.9",
  "title": "",
  "body": " The differential equation has a rate formula . Because this rate formula depends on both and , solutions do not share either horizontal or vertical translations.    "
},
{
  "id": "differential-equation-analysis",
  "level": "1",
  "url": "differential-equation-analysis.html",
  "type": "Section",
  "number": "2.9",
  "title": "Analysis of Differential Equations",
  "body": " Analysis of Differential Equations   Differential equation models and sequence projection models have many similarities as well as differences. Just as we looked for equilibrium solutions for projection models in discrete time, we will look for equilibrium solutions for differential equation models in continuous time. Those equilibria can be stable or unstable. However, unlike sequence models, a differential equation model can not pass across an equilibrium solution. The graphical analysis of sequences using a cobweb diagram for discrete jumps is replaced for differential equations by the idea of a phase line.    Equilibria for Differential Equations  The concept of an equilibrium is that the state of the system is not changing. For variables, this means that the dynamic variables are constant functions with respect to time. Constant functions have a zero rate of change. We find equilibria solutions to a differential equation by solving the equation and look for solutions of the form for some constant . Other solutions that involve the variable are not equilibrium solution but instead describe other points where the instantaneous rate of change is zero but for which the function changes at other times.    Find the equilibrium solution(s) for the differential equation    The rate function involves only the dependent variable . Solving the equilibrium equation gives The solution is of the form is a constant and is therefore an equilibrium solution.      Find the equilibrium solution(s) for the differential equation    The rate function involves only the dependent variable . Solving the equilibrium equation gives either or , which give two equilibrium solutions and .    When we wanted to understand the stability of equilibria resulting from projection function models, we started by considering linear projection functions. For differential equations, we do similar analysis. We start with proportional rates of change models and then apply that to linear rates of change models.   Exponential Growth\/Decay Models   A differential equation of the form where is a constant, so that the rate of change of is proportional to the value of , has solutions that are exponential with rate . That is, for an initial condition , the unique solution will be The growth behavior depends on the sign of :  (exponential growth): as while as .  (exponential decay): as while as .     A differential equation of the form can be transformed into an exponential growth\/decay model by rewriting the model in terms of the equilibrium, found by . The equilibrium is so that the growth rate model can be rewritten as Because is a constant, . The rules of calculus allow us to define and find the differential equation Thus, is an exponential model and is shifted to be centered around the equilibrium.   Shifted Exponential Growth\/Decay Models   A differential equation of the form where and are constant has solutions that are exponential functions with rate shifted by the equilibrium . That is, for an initial condition , the unique solution will be The growth behavior depends on the sign of :  (exponential growth): as (unstable).  (exponential decay): as (stable).     Nonlinear growth rates that depend only on the dependent variable, , have equilibria at all of the values so that . Consider an equilibrium at . We can approximate the differential equation by the tangent line approximation at to determine stability of the equilibrium as long as . Then approximation suggests for values of sufficiently near . This is a linear rate function that leads to a shifted exponential model.   Local Stability of Equilibria   Suppose a differential equation of the form has an equilibrium at so that . Then if , the local stability of the equilibrium can be determined by the sign of .  (exponential growth): increases, at least initially.  (exponential decay): decreases.      The discrete logistic model in discrete time has a growth term defined by . This is saying that the total increment of change in the population over the course of the time increment is given by the formula . If we interpret that formula as a rate of change instead of the total increment of change, we arrive at the continuous-time logistic growth model where and are positive constants.  The equilibria for this model are found by solving to give and . The growth rate formula has a derivative . Computing the derivative at each equilibrium informs us of the stability of that solution.  so is an unstable equilibrium.  so is a stable equilibrium.  The following Sage script generates a typical slope field and several solutions coming from different initial values that illustrate the stability of these equilbria. Notice how solutions move away from the unstable equilibrium solution but towards the stable equilibrium solution.      Phase Lines  A differential equation with a rate that depends only on the dependent variable is called autonomous , such as . This is analogous to a sequence that can be defined recursively with a projection function. For a recursive sequence, we could study it geometrically using a cobweb diagram. When the projection function is above the line , the sequence increases; when the projection function is below the line, the sequence decreases.  For an autonomous differential equation, , we can use the graph of the rate function to understand the behavior of the solution function. When the rate function is positive (above the axis), the solution will be an increasing function. When the rate function is negative (below the axis), the solution will be a decreasing function. Equilibrium solutions correspond to values of where . We can summarize this behavior by drawing a number line with arrows pointing in the direction of increasing or decreasing between equilibrium values. Such a number line is called a phase line .   Consider the autonomous differential equation . We will generate a phase line summary of possible solution behaviors.  The graph of the rate function is a concave up parabola with roots at , shown below.       The roots of the rate function are the equilibrium solutions, and . Between the equilibria, the rate function is negative, so any solutions with initial values between the equilibria will be decreasing functions going away from the upper equilibrium and toward the lower equilibrium. If the initial value is above the equilibria, , then the solution will be an increasing function that grows without bound. If the initial value is below the equilibra, , then the solution will also be an increasing function but will grow at a slower rate as it approaches the lower equilibrium. The equilibria and the three intervals for initial values are summarized in the phase line below.       This phase line might be easier visualized in relation to the graph of different solutions if we drew it vertically on an axis so that arrows pointing to the right (increasing) represent solutions that rise (increasing) and arrows point to the left (decreasing) represent solutions that fall (decreasing). The equilibrium solutions correspond to solutions that remain constant. We see that is an unstable equilibrium while is a stable equilibrium.         "
},
{
  "id": "diffeq-equilibria-3",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-equilibria-3",
  "type": "Example",
  "number": "2.9.1",
  "title": "",
  "body": "  Find the equilibrium solution(s) for the differential equation    The rate function involves only the dependent variable . Solving the equilibrium equation gives The solution is of the form is a constant and is therefore an equilibrium solution.   "
},
{
  "id": "diffeq-equilibria-4",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-equilibria-4",
  "type": "Example",
  "number": "2.9.2",
  "title": "",
  "body": "  Find the equilibrium solution(s) for the differential equation    The rate function involves only the dependent variable . Solving the equilibrium equation gives either or , which give two equilibrium solutions and .   "
},
{
  "id": "diffeq-exponential-models",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-exponential-models",
  "type": "Theorem",
  "number": "2.9.3",
  "title": "Exponential Growth\/Decay Models.",
  "body": " Exponential Growth\/Decay Models   A differential equation of the form where is a constant, so that the rate of change of is proportional to the value of , has solutions that are exponential with rate . That is, for an initial condition , the unique solution will be The growth behavior depends on the sign of :  (exponential growth): as while as .  (exponential decay): as while as .    "
},
{
  "id": "diffeq-shifted-exponential-models",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-shifted-exponential-models",
  "type": "Theorem",
  "number": "2.9.4",
  "title": "Shifted Exponential Growth\/Decay Models.",
  "body": " Shifted Exponential Growth\/Decay Models   A differential equation of the form where and are constant has solutions that are exponential functions with rate shifted by the equilibrium . That is, for an initial condition , the unique solution will be The growth behavior depends on the sign of :  (exponential growth): as (unstable).  (exponential decay): as (stable).    "
},
{
  "id": "diffeq-nonlinear-equilibria-stability",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-nonlinear-equilibria-stability",
  "type": "Theorem",
  "number": "2.9.5",
  "title": "Local Stability of Equilibria.",
  "body": " Local Stability of Equilibria   Suppose a differential equation of the form has an equilibrium at so that . Then if , the local stability of the equilibrium can be determined by the sign of .  (exponential growth): increases, at least initially.  (exponential decay): decreases.    "
},
{
  "id": "diffeq-equilibria-11",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-equilibria-11",
  "type": "Example",
  "number": "2.9.6",
  "title": "",
  "body": " The discrete logistic model in discrete time has a growth term defined by . This is saying that the total increment of change in the population over the course of the time increment is given by the formula . If we interpret that formula as a rate of change instead of the total increment of change, we arrive at the continuous-time logistic growth model where and are positive constants.  The equilibria for this model are found by solving to give and . The growth rate formula has a derivative . Computing the derivative at each equilibrium informs us of the stability of that solution.  so is an unstable equilibrium.  so is a stable equilibrium.  The following Sage script generates a typical slope field and several solutions coming from different initial values that illustrate the stability of these equilbria. Notice how solutions move away from the unstable equilibrium solution but towards the stable equilibrium solution.   "
},
{
  "id": "diffeq-phase-line-2",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-phase-line-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "autonomous "
},
{
  "id": "diffeq-phase-line-3",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-phase-line-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "phase line "
},
{
  "id": "diffeq-phase-line-4",
  "level": "2",
  "url": "differential-equation-analysis.html#diffeq-phase-line-4",
  "type": "Example",
  "number": "2.9.7",
  "title": "",
  "body": " Consider the autonomous differential equation . We will generate a phase line summary of possible solution behaviors.  The graph of the rate function is a concave up parabola with roots at , shown below.       The roots of the rate function are the equilibrium solutions, and . Between the equilibria, the rate function is negative, so any solutions with initial values between the equilibria will be decreasing functions going away from the upper equilibrium and toward the lower equilibrium. If the initial value is above the equilibria, , then the solution will be an increasing function that grows without bound. If the initial value is below the equilibra, , then the solution will also be an increasing function but will grow at a slower rate as it approaches the lower equilibrium. The equilibria and the three intervals for initial values are summarized in the phase line below.       This phase line might be easier visualized in relation to the graph of different solutions if we drew it vertically on an axis so that arrows pointing to the right (increasing) represent solutions that rise (increasing) and arrows point to the left (decreasing) represent solutions that fall (decreasing). The equilibrium solutions correspond to solutions that remain constant. We see that is an unstable equilibrium while is a stable equilibrium.       "
},
{
  "id": "system-examples",
  "level": "1",
  "url": "system-examples.html",
  "type": "Section",
  "number": "3.1",
  "title": "Examples of Interacting Systems",
  "body": " Examples of Interacting Systems   In systems modeling, we have multiple dynamic variables, each of which has an equation governing its dynamic progression in time. We often think of these state variables using a flow diagram . A flow diagram treats each state variable as a reservoir (or a bucket). Arrows pointing into the reservoir represent source terms that correspond to positive rates of change. Arrows pointing out of the reservoir represent loss terms that correspond to negative rates of change. In modeling, each rate of change (arrow on the diagram) has a mathematical formula involving potentially any of the state variables. There may also be graphical representation of which state variables influence the rates in a positive or negative way.  In each example of interacting systems, we identify the state variables and draw a potential flow diagram. Different assumptions on the model might correspond to changes in the flow diagram itself or in the formulas for the rates represented by the arrows in the diagram.    Epidemic Models  In an epidemic model, we consider a single population but consider every individual in the population as being classified according to their status with respect to a disease. In the classic model of a disease involving immunity, there are three categories in the population: individuals who are healthy but susceptible to become sick, those who are sick and therefore infectious, and those who once were sick but have recovered and retain immunity. These three variables are traditionally assigned the variables (susceptible), (infected), and (recovered or removed).  The standard flow diagram for the SIR model tells the story of how an infection spreads through a population. Susceptible individuals become sick after interactions with infected individuals. When there are more infected individuals, it becomes more likely that a person will become infected. Once infected, individuals stay sick for some duration after which they recover. After they recover, they have developed an immunity for the illness and will not become sick again. In addition to this progression of the disease, individuals may die from any stage with some probability. New births in the population generally will be healthy unless our illness has vertical transmission of the disease.  A possible flow diagram for the SIR model is illustrated in the figure below. The three classes are represented by rectangles labeled by the appropriate state variable. Each rate (flow arrow) is labeled according to the process that it represents. A rate will generally always depend on the class that it leaves. To emphasize that the infection rate also depends on the number of infected individuals, we draw a link (dashed line) between the infected class and the infection flow arrow.      SIR Model. Individuals are classified into susceptible, infected and recovered classes. Infections rely on interactions between the susceptible and infected individuals.   Simplifications of the model might come from eliminating some of the flow rates. For example, when studying a disease that progresses quickly relative to the population (such as influenza), we might ignore slow scale processes like birth and death. For a disease that instills permanent immunity, we might eliminate the loss of immunity rate. If a disease never gives immunity, then we might eliminate the recovered class altogether and have recovery send individuals directly back to the susceptible class. Some diseases require additional classes.    Interacting Populations  Ecosystems involve many different interacting species. Interactions might include competition, mutualism, parasitism and predation. In competition, two or more species rely on common resources such that the presence of one species reduces the availability of those resources for the other species. In mutualism, the presence of two interacting species together benefits each species relative to the populations living in isolation. In parasitism, one species takes resources from an individual of another species and may or may not lead to the death of the host but likely reduces the host's fitness. In predation, the predator kills and consumes individuals of the prey species.  The flow diagram for interactions between two species generally look the same, with the difference being whether interactions are beneficial or inhibitory. One way that the diagram can represent this is by using a different type of arrow for inhibitory effects. In the diagrams below, a regular arrow represents a beneficial interaction while a segment ending in a perpendicular cap represents an inhibitory interaction.      Predator-Prey model. A predator species (e.g., lynx) and a prey species (e.g., hare) interact. The predator influences the death rate of the prey and the prey influences the birth rate of the predator.       Competition model. Two species and have an inhibitory effect on the growth of the other species.       Mutualism model. Two species and have an mutually beneficial effect on the growth of the other species.       Parasite-Host model. A parasite species benefits from the presence of the host species while the host fitness is reduced.   From a modeling perspective, we should note that the illustrated competition, mutualism and parasitism model diagrams are structurally equivalent. Only the nature of the interactions (beneficial or inhibitory) are different. Consequently, it may be possible to analyze related models for all three systems by considering different model parameters that might capture these differences.    Age or Stage-Based Models  Even within a single population, we might model the dynamics by a system that accounts for the number of individuals that are of different ages or stages of development. In the simplest cases, individuals steadily progress through a sequence of classifications (such as ages). The only way to leave the progression is to die. Often, only certain categories of individuals will be capable of reproduction (e.g., mature adults). The flow rates between classes generally reflect how long an individual stays in a class. Fast rates correspond to short dwell times. In some models, we may wish to allow individuals to revert to an earlier stage or to alternate between different mature states (e.g., fertile vs infertile).      Age-Based Population model. An illustrative age-based model for a species that becomes fertile in the third and fourth years of life.       Stage-Based Population model. An illustrative stage-based model for a species that lays eggs ( ) that hatch into larvae ( ) which grow into infertile juveniles ( ) and eventually mature adults ( ).    "
},
{
  "id": "system-examples-2-1",
  "level": "2",
  "url": "system-examples.html#system-examples-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "flow diagram "
},
{
  "id": "SIR-system-diagram",
  "level": "2",
  "url": "system-examples.html#SIR-system-diagram",
  "type": "Figure",
  "number": "3.1.1",
  "title": "",
  "body": "    SIR Model. Individuals are classified into susceptible, infected and recovered classes. Infections rely on interactions between the susceptible and infected individuals.  "
},
{
  "id": "predator-prey-system-diagram",
  "level": "2",
  "url": "system-examples.html#predator-prey-system-diagram",
  "type": "Figure",
  "number": "3.1.2",
  "title": "",
  "body": "    Predator-Prey model. A predator species (e.g., lynx) and a prey species (e.g., hare) interact. The predator influences the death rate of the prey and the prey influences the birth rate of the predator.  "
},
{
  "id": "competition-system-diagram",
  "level": "2",
  "url": "system-examples.html#competition-system-diagram",
  "type": "Figure",
  "number": "3.1.3",
  "title": "",
  "body": "    Competition model. Two species and have an inhibitory effect on the growth of the other species.  "
},
{
  "id": "mutualism-system-diagram",
  "level": "2",
  "url": "system-examples.html#mutualism-system-diagram",
  "type": "Figure",
  "number": "3.1.4",
  "title": "",
  "body": "    Mutualism model. Two species and have an mutually beneficial effect on the growth of the other species.  "
},
{
  "id": "parasite-host-system-diagram",
  "level": "2",
  "url": "system-examples.html#parasite-host-system-diagram",
  "type": "Figure",
  "number": "3.1.5",
  "title": "",
  "body": "    Parasite-Host model. A parasite species benefits from the presence of the host species while the host fitness is reduced.  "
},
{
  "id": "age-based-system-diagram",
  "level": "2",
  "url": "system-examples.html#age-based-system-diagram",
  "type": "Figure",
  "number": "3.1.6",
  "title": "",
  "body": "    Age-Based Population model. An illustrative age-based model for a species that becomes fertile in the third and fourth years of life.  "
},
{
  "id": "egg-larva-juvenile-adult-system-diagram",
  "level": "2",
  "url": "system-examples.html#egg-larva-juvenile-adult-system-diagram",
  "type": "Figure",
  "number": "3.1.7",
  "title": "",
  "body": "    Stage-Based Population model. An illustrative stage-based model for a species that lays eggs ( ) that hatch into larvae ( ) which grow into infertile juveniles ( ) and eventually mature adults ( ).  "
},
{
  "id": "interaction-rate-models",
  "level": "1",
  "url": "interaction-rate-models.html",
  "type": "Section",
  "number": "3.2",
  "title": "Modeling Interaction Rates",
  "body": " Modeling Interaction Rates   Once we have formulated a flow diagram for our system, we need to establish a mathematical model by determining how to compute each of the rates. In unusual cases, we might have plentiful data with which we can estimate actual quantitative relationships between the state variables and the relevant rates. More commonly, we have qualitative assumptions about the nature of the relationship defining the rates. We use these qualitative assumptions to establish a general form of the relationship involving parameters. Often, we can then apply analysis on the model to understand possible behaviors as they relate to parameter values.  In this section, we explore some of common qualitative relationships between state variables and rates associated with those variables. Qualitative descriptions include mathematical descriptions of relationships including traits of increasing and decreasing as well as concavity and asymptotic behavior. By identifying likely traits associated with a system of interest, we can identify possible model equations to use for the rates.    Linear Rates and Linear Combinations  The simplest rate of all is a constant rate. We use a constant rate when the rate at which a particular event does not depend on the state variables. Usually, these rates are related to an external environment. For example, we might use a constant rate for immigration to describe the rate at which individuals arrive from an external population that we are not modeling. Or we might use a constant rate to describe how fast doctors can treat sick patients.  The next simplest model for a rate of change is one that is proportional to a single state variable. We can usually think of these rates as saying that each individual (or other relevant unit being measured) represented by that variable contributes a specific amount per unit time and that amount does not depend on the total number of individuals. By multiplying by the total number of individuals (or total quantity), we have a rate that is the sum of the contributions of the individuals.   Suppose a population of size has a growth term that comes from a constant immigration rate of 100 individuals per year and a constant per capita growth rate of 2\\% per year. The immigration will be modeled using a constant rate and the population growth will be represented as begin proportional to the population size. The total growth rate would then be modeled by Note that this model only describes the rate of a single flow that would be part of a bigger differential equation.   Sometimes, a rate is represented as the sum of multiple contributions, each of which is defined by a constant per capita. For example, suppose in an age-based model that three-year old plants produce a different number of seeds than a four-year old plant. If we let and represent the number of plants of age three and four, respectively, and and are the average number of seeds produced by three- and four-year old plants, respectively, then the total number of seeds produced would be given by  We call such a sum of proportional terms a linear combination , in this case a linear combination of and , or even of if we realized that all missing terms had proportionality constants of zero. To be a linear combination, all of the proportionality constants must really be constants, not other variables, although we might represent them as parameters. We will later learn that rates that are linear combinations of the state variables are one of the most important representations in order to do analysis.    Logistic Growth with Functional Dependence  One strategy for modeling systems is to repurpose models that were used for single populations in a way that informs the system. For example, when considering a single population , one way to model the growth of that population so that it had a carrying capacity was to use the logistic growth model, The motivation behind this formula is that the per capita growth rate starts at when is small and linearly decreases until it is zero at the carrying capacity . If starts above , then the per capita growth is negative and the population decreases. Thus, this model can be considered to include both births and deaths in a combined formula.  We can repurpose this model for use in a system. One way is to use the model for the rate without change to account for that growth and death rates of the system that only depend on the population. We would then add additional rate terms to account for growth or loss that depended on other variables.  Alternatively, we might modify the logistic growth rate formula to account for the presence of other variables. For example, we might consider the carrying capacity to depend on another population . That is, we can think of the carrying capacity as a decreasing function of , such as with a linear function so that the per capita growth rate for now has the form . The new effective growth rate that would be used in the differential equation is the per capita rate times the population , given by  We can illustrate the effect of the population by graphing the effective per capita growth rate as a function of using different values of . This is illustrated in the figure below. Notice that for small populations , the per capita growth is not changing much. It is only when starts to be larger that the effect of is observed. This model formula seems to require an assumption that competition only occurs when both populations are large.      Per capita growth rate for a population where the carrying capacity depends on another population .   It might be a better modeling assumption to suppose that the per capita growth rate is affected at both high and low populations in the presence of another population . Consider an alternate modeling strategy where we think of as representing total population capacity units in the environment. We can then think of the term in the per capita growth formula as representing the fraction of growth capacity remaining.  The presence of a population uses up some of that capacity so that we want to reduce the fraction of growth capacity due to as well as . However, one individual of may not occupy the same number of capacity units as an individual from . We use a per capita growth rate for modeled by the expression The graph of the per capita growth rate corresponding to increasing values of is given below. The figure illustrates a more uniform reduction on the growth rate due to for both low and high values for .      Per capita growth rate for a population where the another population occupies part of the carrying capacity available for .   Similar strategies can be adopted for any model that incorporates density dependence. For example, if a growth rate for an isolated population includes an exponential decay term to incorporate a decreasing rate due to population density like , then the presence of a second population that adds to the crowding could be incorporated with a term like . In the same way as for the logistic growth term, this consider the crowding factor as having individuals impact the growth rate in an equivalent manner as having an extra individuals in the population.    Law of Mass Action for Interactions  In simple chemical reactions, the principle of mass action states that the rate of a reaction is proportional to the product of the concentrations of the reactants. The premise behind this principle is that the chemical reaction occurs in a well-mixed solution and that the number of molecular interactions of the reactants that occur per unit time will be proportional to the product of the concentrations. Of those interactions, some fraction will result in the reaction proceeding.  Many interactions in settings other than chemical reactions can also be modeled in a similar way. Suppose that there are two populations and that are interacting to create certain events (e.g., causing infections, predators killing prey, competition reducing a birth rate). The law of mass action can arise any time we can think of the events being counted as being the sum of contributions from each individual in population such that the average number of events per individual is itself proportional to the size of the population . In other words, the assumption is that the number of events per individual in population will double if the population doubles, will triple if the population triples, and so on.   The logistic growth model with total capacity can be interpreted as a law of mass action interaction.  Suppose a population grows according to a logistic growth law, in the absence of population . Suppose that individuals from populations and compete in such a way that effectively has an additional death rate resulting from competitive interactions with . For the interactions to obey a law of mass action, we would require that the per capita death rate due to competition is proportional to the population size , say an average of deaths per individual per unit time. Then the total death rate due to competition would be . The modified model that includes the deaths due to competition would then be given by  This model is mathematically equivalent to the differential equation introduced earlier where we thought of as occupying some of the carrying capacity units for . In particular, we can rewrite this as Thus, the two models are equivalent where . This equivalence is another reason that this model for competition is preferred.     Saturating Functional Response  The law of mass action often makes good sense when the values of the state variables are not too big. However, there are often cases where we expect the proportional relation assumed for mass action to fail. Consider the example of a population that is consuming a resource (e.g., predators consuming prey, bacteria consuming a sugar substrate, or herbivores consuming vegetation). When the resource is limited, it makes sense that each individual in the population could double the amount of resource it consumes if the resource itself were to double. However, when the resource is abundant, doubling the resource likely has little effect on consumption rate.  The rate of consumption is not something that can increase indefinitely. The rate is limited due to the ability of the individual to complete a consumption event. A predator must spend the time to catch its prey, eat the prey, and perhaps even digest the prey before undertaking another predation event. A bacteria uses active transport to bring glucose from the environment into the cell for metabolism and the bacteria has a limited number of sites to perform this operation. An herbivore takes time to eat vegetation and doubling the amount of vegetation does not increase the rate of consumption if the herbivore is already eating full-time.  We need to adapt our model to account for saturation . Saturation corresponds to the mathematical idea of a horizontal asymptote , where a function effectively behaves like a constant when a variable becomes sufficiently large. Any function that has a horizontal asymptote might conceivably be used as a model for saturation. One of the most commonly used models is a simple rational function.  Recall from our discussion of mass action that we could think of as counting the number of interaction events per individual in the population. We modify this term to incorporate a horizontal asymptote using a modified form . The figure below illustrates the graphs of the specific mass action rate and the saturating specific rate.      Specific rate of interactions per unit of resulting from individuals showing mass action and saturating .   For small values of , the saturating model behaves almost identically to the law of mass action. However, for larger values of , the specific rate of events saturates at a value of . The value , which is measured in the same units as , corresponds to that value of for which the specific rate is exactly half way to saturation. Thus, is called the half-saturation level for .  In ecology, these interaction curves describe consumption rates and are called the functional response to the food density. An ecologist named C. S. Holling proposed a classification of the functional response curves as falling under three general categories. A Type I functional response corresponds to the law of mass action, although it may also be piecewise linear, switching to a constant saturating rate. The example above is consider a Type II functional response because it is an increasing and concave down function. A Type III functional response would be concave up at low food densities and then switch to concave down as consumption approached its saturating level. The figure below illustrates typical examples.      Illustration of Type I (red), Type II (blue), and Type III (orange) functional response curves.     Switching Functional Response  The Type III functional response captures a new idea. Both Type I and Type II functional responses have the characteristic that at low food densities, consumption essentially follows a law of mass action. That is, each organism is consuming the food at a rate that is proportional to the density of that food. This might reflect the idea that the organism is eating the food as it is encountered. However, a Type III functional response that is concave up for low food densities does not follow this pattern. Instead, it is as if the organism is rejecting opportunities to consume the food at low densities and only begins to consume in proportion to encounters if the food density exceeds some threshold. This is an example of switching behavior.  Switching occurs when the dynamic relationships change according to different conditions. Typically, we consider switching in relationship to individual state variables. When a state variable is below a threshold, one dynamic relationship exists; when the state variable is above a threshold, another dynamic relationship exists. The cross-over is often continuous so that near the threshold, the dynamics is an intermediate combination of the two relationships.  Functions that have two different horizontal asymptotes and a smooth connection between them are often used for switching functions. Combinations of exponential functions provide one example.   Consider the function If , then the horizontal asymptotes are given by limits If , then the direction of the switching is reversed with horizontal asymptotes given by The steepness of the transition between the asymptotes is determined by the magnitude of the larger the magnitude of , the steeper the transition will be. The figure below illustrates several examples with .      Graph of with values (red), (blue) and (orange).   The graph of this switching function is symmetric around the point . At this point, the function is exactly half-way between the two limiting values. We consider this point to be the location of the switch. Mathematically, this point is also an inflection point, a consequence of the symmetry of this particular function. We can create a switching function at any desire location by applying a horizontal shift. It helps if we rewrite our original formula Then we can get the same switching behavior around a switching point using   Another common example of a function used for switching between two values involves the arctangent function. Recall that the arctangent function is the inverse of the trigonometric tangent function, restricted to a domain . Because the tangent function has all values in , the inverse function will be defined with a domain and a range of . The vertical asymptotes of the tangent become horizontal asymptotes of the arctangent. This is precisely the behavior we desire from a switching function.   The arctangent function can be used as a switching function. The left and right horizontal asymptotes are given by and the function is symmetric around the point at . We can construct a function that goes between values 0 and 1 by dividing by and then adding : (Sometimes we want to go between values and ; we do this by just multiplying by .)  We can change the steepness of the transition by a horizontal compression with factor and the location around by a horizontal shift to get The figure below illustrates several examples.      Graph of with values (red), (blue) and (orange).     "
},
{
  "id": "interaction-rate-models-3-4",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-3-4",
  "type": "Example",
  "number": "3.2.1",
  "title": "",
  "body": " Suppose a population of size has a growth term that comes from a constant immigration rate of 100 individuals per year and a constant per capita growth rate of 2\\% per year. The immigration will be modeled using a constant rate and the population growth will be represented as begin proportional to the population size. The total growth rate would then be modeled by Note that this model only describes the rate of a single flow that would be part of a bigger differential equation.  "
},
{
  "id": "interaction-rate-models-3-6",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-3-6",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "linear combination "
},
{
  "id": "interaction-rate-models-4-6",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-4-6",
  "type": "Figure",
  "number": "3.2.2",
  "title": "",
  "body": "    Per capita growth rate for a population where the carrying capacity depends on another population .  "
},
{
  "id": "interaction-rate-models-4-9",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-4-9",
  "type": "Figure",
  "number": "3.2.3",
  "title": "",
  "body": "    Per capita growth rate for a population where the another population occupies part of the carrying capacity available for .  "
},
{
  "id": "interaction-rate-models-5-4",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-5-4",
  "type": "Example",
  "number": "3.2.4",
  "title": "",
  "body": " The logistic growth model with total capacity can be interpreted as a law of mass action interaction.  Suppose a population grows according to a logistic growth law, in the absence of population . Suppose that individuals from populations and compete in such a way that effectively has an additional death rate resulting from competitive interactions with . For the interactions to obey a law of mass action, we would require that the per capita death rate due to competition is proportional to the population size , say an average of deaths per individual per unit time. Then the total death rate due to competition would be . The modified model that includes the deaths due to competition would then be given by  This model is mathematically equivalent to the differential equation introduced earlier where we thought of as occupying some of the carrying capacity units for . In particular, we can rewrite this as Thus, the two models are equivalent where . This equivalence is another reason that this model for competition is preferred.  "
},
{
  "id": "interaction-rate-models-6-4",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-6-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "saturation horizontal asymptote "
},
{
  "id": "interaction-rate-models-6-6",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-6-6",
  "type": "Figure",
  "number": "3.2.5",
  "title": "",
  "body": "    Specific rate of interactions per unit of resulting from individuals showing mass action and saturating .  "
},
{
  "id": "interaction-rate-models-6-7",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-6-7",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "half-saturation "
},
{
  "id": "interaction-rate-models-6-8",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-6-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "functional response "
},
{
  "id": "interaction-rate-models-6-9",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-6-9",
  "type": "Figure",
  "number": "3.2.6",
  "title": "",
  "body": "    Illustration of Type I (red), Type II (blue), and Type III (orange) functional response curves.  "
},
{
  "id": "interaction-rate-models-7-3",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-7-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Switching "
},
{
  "id": "interaction-rate-models-7-5",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-7-5",
  "type": "Example",
  "number": "3.2.7",
  "title": "",
  "body": " Consider the function If , then the horizontal asymptotes are given by limits If , then the direction of the switching is reversed with horizontal asymptotes given by The steepness of the transition between the asymptotes is determined by the magnitude of the larger the magnitude of , the steeper the transition will be. The figure below illustrates several examples with .      Graph of with values (red), (blue) and (orange).   The graph of this switching function is symmetric around the point . At this point, the function is exactly half-way between the two limiting values. We consider this point to be the location of the switch. Mathematically, this point is also an inflection point, a consequence of the symmetry of this particular function. We can create a switching function at any desire location by applying a horizontal shift. It helps if we rewrite our original formula Then we can get the same switching behavior around a switching point using  "
},
{
  "id": "interaction-rate-models-7-7",
  "level": "2",
  "url": "interaction-rate-models.html#interaction-rate-models-7-7",
  "type": "Example",
  "number": "3.2.9",
  "title": "",
  "body": " The arctangent function can be used as a switching function. The left and right horizontal asymptotes are given by and the function is symmetric around the point at . We can construct a function that goes between values 0 and 1 by dividing by and then adding : (Sometimes we want to go between values and ; we do this by just multiplying by .)  We can change the steepness of the transition by a horizontal compression with factor and the location around by a horizontal shift to get The figure below illustrates several examples.      Graph of with values (red), (blue) and (orange).   "
},
{
  "id": "system-phase-space",
  "level": "1",
  "url": "system-phase-space.html",
  "type": "Section",
  "number": "3.3",
  "title": "Dynamical Systems and Phase Space",
  "body": " Dynamical Systems and Phase Space   We are interested in studying what happens in an interacting system. For these systems, our system must have more than one dynamic variable. We call the system a dynamical system . In this section, we introduce some terminology for how we think about dynamical systems. We will be able to visualize these concepts graphically when there are two or three dynamic variables. When there are more than three variables, we will work by analogy even though we aren't able to visualize the result.    Vector Fields  A continuous dynamical system is defined in terms of a system of differential equations. Each state variable has a rate of change (the derivative). In a dynamical system, there exists a function of the state variables and the independent variable that equals this rate of change at all times. In an abstract system with state variables, labeled , where the time dependence is explicitly stated, there are functions of the state variables such that The collection of functions defines a vector field .   Existence and Uniqueness of Initial Value Problem   If each of the component rate functions are continuous and all of the partial derivatives are continuous in a neighborhood of the initial value , then the initial value problem defined by the vector field and initial values for has a unique solution for some interval .    The existence and uniqueness theorem guarantees that if we specify the state of the system at a time in which the vector field changes smoothly relative to time and also relative to the values of the state variables (this is what continuity of the partial derivatives guarantees), then the state will follow a flow defined by the vector field. In many cases, the vector field does not depend on time and we have an autonomous system of differential equations. In these cases, we can often visualize solutions to the differential equations by create a plot of the vector field.  A vector is a mathematical object that consists of both a direction and a magnitude. Graphically, we usually represent a vector as an arrow. The length of the arrow represents its magnitude and the direction is the direction of the arrow from its root (the straight segment) to its tip (the arrow). A vector can also be determined from its components.  Standard components correspond to perpendicular directions, with one direction for each state variable. A system with two state variables has a vector field defined in the plane with two directions. The direction of the -axis corresponds to the first state variable and the -axis corresponds to the second state variable. A vector is specified by giving a value for each coordinate direction, say (similar to a point). The vector, drawn at a location in the plane corresponds to an arrow with a root at and the tip at . That is, the vector gives a displacement from the root to the tip.  The vector field functions define at every moment and state a rate vector A solution can be visualized as a point moving through the state space such that its velocity is at each instant defined by . For an autonomous system, the velocity depends only on the current state and we call the state space the phase space. When the vector field depends explicitly on time, we must add the time variable as a new state variable and the phase space is one dimension larger than the state space.  We illustrate the ideas with some two-dimensional examples and use Sage to generate illustrative figures.   An example from physics is the harmonic oscillator (mass on a spring). In the absence of friction, the only force is from the spring, proportional to and opposing the displacement. The state variables are the displacement and the velocity . The system of differential equations is given by The rate for is just the definition of velocity. The rate for is acceleration and is a consequence of Newton's law where is the force of the spring.  The vector field is identified by considering an order for our state variables, and , with corresponding rate functions and . The phase plane is the -plane. The vector field corresponds to placing at each point a vector . Computer generated plots of vector fields usually rescale the vectors but preserve the correct directions and relative lengths.  The following Sage script generates a vector field for this system.   When you execute the Sage script and see the results, you should observe arrows that look like they generate a circular pattern (an ellipse, actually). The closer to the origin, , the smaller the arrows appear.  The vector field allows us to tell the story of what happens to the oscillator. Imagine stretching the string for a positive displacement by 1 unit of distance. Right when we let go, we are at a state of and , which appears on the -axis of the phase space. The vector field points down, , which means that we start to gain a little negative velocity. Immediately, the negative velocity starts to cause the displacement to decrease. This corresponds to following the ellipse in the fourth quadrant.  Eventually, the state of the system reaches with some maximum negative velocity . This corresponds to a point on the lower -axis. The vector field is horizontal and directed left, . The velocity causes the displacement to become negative and immediately, the acceleration begins to be positive and the velocity gradually slows down to zero, at which time we have returned to the -axis on the left side. It is not yet obvious, but conservation of energy guarantees that we have reached a negative displacement exactly equal to our original positive displacement. The state of the system continues through the second and first quadrant, ultimately returning to its initial point, whereon the cycle is repeated.  The path the state follows through phase space is called the orbit . If we include the time variable to extend the phase space, the path is called the trajectory . If we solve the initial value problem numerically, we can add an orbit to the plot of the vector field. In addition, we often wish to see the graphs of the individual state variables as functions of time. This is accomplished by plotting and .     In the early 1900s, two scientists, Alfred Lotka and Vito Volterra, independently developed a system of differential equations to describe the dynamics of two populations a producer or prey and a consumer or predator. The system of equations, now called the Lotka Volterra predator prey model, has two state variables. Let represent the size of the consumer (or carnivore) population and let represent the size of the producer (or prey) population. The basic model assumes that the producer would grow in direct proportion to its current population and that the consumer would die in direct proportion to its population. Each consumer kills and eats the producer at a rate proportional to the producer population, and births of the consumer are proportional to the consumption rate. The flow diagram for the model is shown below.       The resulting system of differential equations defines our vector field. The following Sage script generates a vector field and plots a sample orbit in the phase plane. A graph of the corresponding state variables as functions of time is also generated.      Nullclines and Equilibria  A nullcline is a subset of the phase space of points where one of the rate functions in the vector field equals zero. In a two-dimensional system, a nullcline is typically a curve. In a three-dimensional system, a nullcline is typically a surface. In higher dimensions, a nullcline defines what is called a hypersurface, which is the generalization of a surface in three dimensions. Nullclines divide the phase space into disjoint regions in which the state variable is exclusively either increasing or decreasing.  An equilibrium is a point in phase space such that all of the state variables are constant. This requires that the point is on every variable's nullcline. So we can find equilibrium points by finding where the nullclines intersect.  We can create a graph that shows the nullclines using something called an implicit plot. The way that an implicit plot works is that a formula is computed at every point on a grid in the plane. We could think of these values as defining the height of a surface above or below each point in the plane. The implicit plot uses this surface to draw a contour in the plane where the height equals zero. Because the surface is not known exactly but is only measured at a grid of points, the contour is only approximate.   The Lotka Volterra predator prey model given by is a two-dimensional system. The -nullcline is the set of all points in the phase plane where , Similarly, the -nullcline is the set of all points where ,  To illustrate where an implicit plot comes from, the following Sage script plots the surface defined by the -rate formula with a contour showing the curve where the rate is zero. This approximate contour is the graphed as an implicit plot.   The -nullcline divides the phase plane into regions of -directionality. The intersection points are equilibria, which for the given model parameters occur at and . Within each region, the state variable either exclusively increases ( ) or exclusively decreases ( ). We can add arrows to visualize the result. The values used to define the ends of arrows was determined manually after looking at the phase plane with the nullcline shown to make the arrow centered.   Ultimately, we want to know the direction for both and . We plot the nullclines together, using different colors to distinguish them. We test the sign of the rate functions at points in the regions and draw arrows showing the direction. Conveniently, we could have Sage do the work once we identify the points by automating the drawing of arrows. The following script generates the nullclines, after some experimentation to get the legend looking appropriate.   Looking at the phase plane, we see nine distinct regions separated by the nullclines. The Sage script below tests the sign of the vector field rates at nine points, one from each region and draws horizontal and vertical arrows rooted at that point.    Higher dimensions obey the same ideas in principle but are harder to visualize. Even three dimensions can be a little challenging to interpret.   The SIR model for infectious diseases considers a single population where each individual can be categorized as susceptible to the disease, infected, and recovered and immune from the disease. The state variables , , and count the number of individuals in each category. Assuming that only healthy individuals give birth subject to a carrying capacity and infected individuals die at a higher rate than other individuals, a simple model is given by the system of differential equations The phase space is three-dimensional.  The Sage script below uses three-dimensional implicit plots to create approximate nullclines (these will be surfaces) for the three state variables. It is hard to see the intersection of all three surfaces. The script includes a step to solve for the equilibrium points.     "
},
{
  "id": "system-phase-space-2-1",
  "level": "2",
  "url": "system-phase-space.html#system-phase-space-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "dynamical system "
},
{
  "id": "vector-fields-2",
  "level": "2",
  "url": "system-phase-space.html#vector-fields-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "vector field "
},
{
  "id": "thm-existence-uniqueness-system",
  "level": "2",
  "url": "system-phase-space.html#thm-existence-uniqueness-system",
  "type": "Theorem",
  "number": "3.3.1",
  "title": "Existence and Uniqueness of Initial Value Problem.",
  "body": " Existence and Uniqueness of Initial Value Problem   If each of the component rate functions are continuous and all of the partial derivatives are continuous in a neighborhood of the initial value , then the initial value problem defined by the vector field and initial values for has a unique solution for some interval .   "
},
{
  "id": "vector-fields-5",
  "level": "2",
  "url": "system-phase-space.html#vector-fields-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "vector "
},
{
  "id": "vector-fields-9",
  "level": "2",
  "url": "system-phase-space.html#vector-fields-9",
  "type": "Example",
  "number": "3.3.2",
  "title": "",
  "body": " An example from physics is the harmonic oscillator (mass on a spring). In the absence of friction, the only force is from the spring, proportional to and opposing the displacement. The state variables are the displacement and the velocity . The system of differential equations is given by The rate for is just the definition of velocity. The rate for is acceleration and is a consequence of Newton's law where is the force of the spring.  The vector field is identified by considering an order for our state variables, and , with corresponding rate functions and . The phase plane is the -plane. The vector field corresponds to placing at each point a vector . Computer generated plots of vector fields usually rescale the vectors but preserve the correct directions and relative lengths.  The following Sage script generates a vector field for this system.   When you execute the Sage script and see the results, you should observe arrows that look like they generate a circular pattern (an ellipse, actually). The closer to the origin, , the smaller the arrows appear.  The vector field allows us to tell the story of what happens to the oscillator. Imagine stretching the string for a positive displacement by 1 unit of distance. Right when we let go, we are at a state of and , which appears on the -axis of the phase space. The vector field points down, , which means that we start to gain a little negative velocity. Immediately, the negative velocity starts to cause the displacement to decrease. This corresponds to following the ellipse in the fourth quadrant.  Eventually, the state of the system reaches with some maximum negative velocity . This corresponds to a point on the lower -axis. The vector field is horizontal and directed left, . The velocity causes the displacement to become negative and immediately, the acceleration begins to be positive and the velocity gradually slows down to zero, at which time we have returned to the -axis on the left side. It is not yet obvious, but conservation of energy guarantees that we have reached a negative displacement exactly equal to our original positive displacement. The state of the system continues through the second and first quadrant, ultimately returning to its initial point, whereon the cycle is repeated.  The path the state follows through phase space is called the orbit . If we include the time variable to extend the phase space, the path is called the trajectory . If we solve the initial value problem numerically, we can add an orbit to the plot of the vector field. In addition, we often wish to see the graphs of the individual state variables as functions of time. This is accomplished by plotting and .   "
},
{
  "id": "vector-fields-10",
  "level": "2",
  "url": "system-phase-space.html#vector-fields-10",
  "type": "Example",
  "number": "3.3.3",
  "title": "",
  "body": " In the early 1900s, two scientists, Alfred Lotka and Vito Volterra, independently developed a system of differential equations to describe the dynamics of two populations a producer or prey and a consumer or predator. The system of equations, now called the Lotka Volterra predator prey model, has two state variables. Let represent the size of the consumer (or carnivore) population and let represent the size of the producer (or prey) population. The basic model assumes that the producer would grow in direct proportion to its current population and that the consumer would die in direct proportion to its population. Each consumer kills and eats the producer at a rate proportional to the producer population, and births of the consumer are proportional to the consumption rate. The flow diagram for the model is shown below.       The resulting system of differential equations defines our vector field. The following Sage script generates a vector field and plots a sample orbit in the phase plane. A graph of the corresponding state variables as functions of time is also generated.   "
},
{
  "id": "system-phase-space-4-2",
  "level": "2",
  "url": "system-phase-space.html#system-phase-space-4-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "nullcline "
},
{
  "id": "system-phase-space-4-3",
  "level": "2",
  "url": "system-phase-space.html#system-phase-space-4-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "equilibrium "
},
{
  "id": "system-phase-space-4-5",
  "level": "2",
  "url": "system-phase-space.html#system-phase-space-4-5",
  "type": "Example",
  "number": "3.3.5",
  "title": "",
  "body": " The Lotka Volterra predator prey model given by is a two-dimensional system. The -nullcline is the set of all points in the phase plane where , Similarly, the -nullcline is the set of all points where ,  To illustrate where an implicit plot comes from, the following Sage script plots the surface defined by the -rate formula with a contour showing the curve where the rate is zero. This approximate contour is the graphed as an implicit plot.   The -nullcline divides the phase plane into regions of -directionality. The intersection points are equilibria, which for the given model parameters occur at and . Within each region, the state variable either exclusively increases ( ) or exclusively decreases ( ). We can add arrows to visualize the result. The values used to define the ends of arrows was determined manually after looking at the phase plane with the nullcline shown to make the arrow centered.   Ultimately, we want to know the direction for both and . We plot the nullclines together, using different colors to distinguish them. We test the sign of the rate functions at points in the regions and draw arrows showing the direction. Conveniently, we could have Sage do the work once we identify the points by automating the drawing of arrows. The following script generates the nullclines, after some experimentation to get the legend looking appropriate.   Looking at the phase plane, we see nine distinct regions separated by the nullclines. The Sage script below tests the sign of the vector field rates at nine points, one from each region and draws horizontal and vertical arrows rooted at that point.   "
},
{
  "id": "system-phase-space-4-7",
  "level": "2",
  "url": "system-phase-space.html#system-phase-space-4-7",
  "type": "Example",
  "number": "3.3.6",
  "title": "",
  "body": " The SIR model for infectious diseases considers a single population where each individual can be categorized as susceptible to the disease, infected, and recovered and immune from the disease. The state variables , , and count the number of individuals in each category. Assuming that only healthy individuals give birth subject to a carrying capacity and infected individuals die at a higher rate than other individuals, a simple model is given by the system of differential equations The phase space is three-dimensional.  The Sage script below uses three-dimensional implicit plots to create approximate nullclines (these will be surfaces) for the three state variables. It is hard to see the intersection of all three surfaces. The script includes a step to solve for the equilibrium points.   "
},
{
  "id": "backmatter-2",
  "level": "1",
  "url": "backmatter-2.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": " This book was authored in PreTeXt .  "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')
  this.metadataWhitelist = ['position']

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
